# Big Picture

Imagine you have a goal journal that helps you:
1. Set goals (like "run a marathon" or "read 20 books")
2. Track what you actually do (ran 5 miles today, read 30 pages)
3. See how your actions connect to your goals
4. Organize everything into 10-week chunks (like school terms!)

Think of it like a really smart to-do list that remembers what you value and shows you how you're doing.

# Foundation 

## Model Layer 

This app organizes entities in layers:

1. Abstraction
- Actions **Question: Should this be abstracted to Behaviors to accomodate polymorphism on user entries, healthkit imports, calendar imports?**
- Expectations
- Measures
- PersonalValues
- TimePeriods

2. Basics

Lighter, day-to-day entities that represent what end users enteract with at a conceptual/narrative level

- Expectations: Goals, Milestones, Obligations
- TimePeriods: Terms

3. Composits

These are relationship tables that connect things:

- MeasuredActions = "This action had 5 miles" (links Action + Measure)
- GoalRelevances = "This goal serves my value of health" (links Goal + Value)
- ActionGoalContributions = "This run helped my marathon goal" (links Action + Goal)

Why connections matter: You can say "show me all actions that helped my reading goal" or "what values does this goal serve?"

### Why You Need both Composit structs and ViewModels:

**Question:** Do ViewModels not obviate the need for composits in the Model layer?

Short answer: No! They serve completely different purposes.

#### Composits (Database Layer):

What: Junction tables storing many-to-many relationships
Where: In the database (measuredActions, goalRelevances, actionGoalContributions)
Purpose: Persistent storage of relationships

Example: actionGoalContributions
```sql
CREATE TABLE actionGoalContributions (
    id TEXT PRIMARY KEY,
    actionId TEXT,
    goalId TEXT,
    contributionAmount REAL,
    createdAt TEXT
);
```
This says: "Action #123 contributed 5 miles toward Goal #456"

#### ViewModels (UI Layer):

What: Observable classes managing UI state
Where: In Swift code (GoalsListViewModel, ActionFormViewModel)
Purpose: Connect views to data, handle loading/errors

Example: GoalsListViewModel
```swift
@Observable
@MainActor
class GoalsListViewModel {
    var goals: [GoalWithDetails] = []  // ← Fetched from DB
    var isLoading = false
    var errorMessage: String?

    func loadGoals() async {
        goals = try await repository.fetchAll()
    }
}
```

#### Why we need both:

Scenario: Show "Actions that helped this goal"

Step 1: Composits store the relationship

```sql
-- Database: actionGoalContributions table
actionId | goalId | contributionAmount
---------|--------|-------------------
abc-123  | goal-1 | 5.0
def-456  | goal-1 | 3.2
```

Step 2: Repository fetches the data

```swift
// GoalRepository uses Composits to JOIN
let sql = """
SELECT a.*, c.contributionAmount
FROM actions a
JOIN actionGoalContributions c ON a.id = c.actionId
WHERE c.goalId = ?
"""
// Returns: [ActionWithContribution]
```

Step 3: ViewModel holds it for the UI
```swift
// GoalDetailViewModel
var contributingActions: [ActionWithContribution] = []

func loadContributions() async {
    contributingActions = try await repository.fetchContributingActions(goalId)
}
```
```swift
Step 4: View displays it
// GoalDetailView
ForEach(viewModel.contributingActions) { action in
    Text("\(action.title): \(action.contributionAmount) miles")
}
```


#### What If We Removed Composits?

Bad idea! You'd have to store relationships somewhere:

Option A: Duplicate data in ViewModels (temporary, lost on quit)
```swift
// ViewModel stores it (lost when app closes!)
var goalToActionsMap: [UUID: [Action]] = [:]
```

Option B: Embed in parent models (denormalized, messy)
```sql
-- Store as JSON array in goals table (yuck!)
CREATE TABLE goals (
    id TEXT,
    contributingActionIds TEXT  -- "[abc-123, def-456]"
);
```

Both are way worse than Composits!


The Division of Labor:

| Component    | Responsibility                     | Lifespan                |
|--------------|------------------------------------|-------------------------|
| Composits    | Store relationships persistently   | Forever (until deleted) |
| Repositories | Fetch relationships from Composits | Per query               |
| ViewModels   | Hold fetched data for UI           | While view is visible   |
| Views        | Display ViewModel data             | While on screen         |



## Service Layer

Why separate Coordinators, Validators, and Repositories?

Bad way:

  ```swift
  // View does everything - messy!
  saveGoal() {
      // Check if valid... 
      // Save expectation...
      // Save goal...
      // Save measures...
      // Update UI...
  }
    ```

Better way:
```swift
  // Each piece has one job
  Validator.check(goal) → "Is this OK?"
  Coordinator.save(goal) → "Save everything together"
  Repository.fetch() → "Get the data"
  ViewModel.loadGoals() → "Show it on screen"

```

Each piece can be tested separately, and you can swap pieces without breaking others.

### Coordinators

When you create or update things, coordinators make sure everything gets saved correctly together.

  Example: GoalCoordinator.create() saves:
  - The Expectation (title, description, importance)
  - The Goal (dates, action plan)
  - The Measures (what you're tracking)
  - The Values (what this goal serves)

All in one atomic write → If anything fails, nothing gets saved (keeps database safe!)


### Validators

Before saving, validators check:
  - Is the title filled in?
  - Are dates valid (start before end)?
  - Do required fields exist?

### Repositories

When you want to show data, repositories fetch it:
- GoalRepository.fetchAll() → Get all goals with their measures and values
- ActionRepository.fetchAll() → Get all actions with measurements

Uses "JSON aggregation" to fetch everything in one query instead of 100+ separate queries


### ViewModels

These connect the UI to the data:
  - Holds the data the screen shows (var goals: [Goal] = [])
  - Has loading states (var isLoading = false)
  - Calls repositories to fetch data
  - Calls coordinators to save data

Marked with @Observable so SwiftUI automatically updates the screen when data changes.

## Database Layer

The database is "normalized" (3NF), which means:
  - No duplicates → If you change a goal's title, you only change it once
  - Fast queries → Finding "all actions for this goal" is super fast with indexes
  - Flexible relationships → One action can help multiple goals, one goal can serve multiple values

  This is like having separate folders for "Books," "Authors," and "Book-Author Links" instead of one giant messy spreadsheet where you'd copy author names over and over.




## Questions: 

1. How do we represent the structs and classes that deal with the LLM tools, AppleHealthKit data, SemanticTypes, and WrapperTypes? Do these break the 3-layer imagery?
2. Are there aspects of this abstraction that go too far too soon? Are there adjustments that we should make to abstract differently?
3. How do we maintain the indexes we need and remove the ones we don't as the app evolves over time?
4. 

# Strategies

## Dependency Injection 

Dependency Injection means "giving an object what it needs from the outside, rather than letting it create its dependencies internally." 

Without DI (bad pattern):

```swift
public final class Exporter {
    private let database = Database()  // ❌ Creates its own dependency
}
```

With DI (current pattern):

```swift
public final class Exporter {
    private let database: any DatabaseWriter  // ✅ Receives dependency
    
    public init(database: any DatabaseWriter) {
        self.database = database
    }
}
```

When Sources/Services/ImportExport/Exporter.swift creates its own database, it's "hardwired" to that specific implementation. 

With DI, you can:
    Test with mocks: Pass a fake database that doesn't touch disk
    Swap implementations: Use different database configurations without changing Exporter
    Control lifecycle: The caller decides when/how the database is created

The Exporter requires database access, and DatabaseWriter is the contract for that access. This can can be any DatabaseWriter - The any keyword means it accepts any concrete type conforming to DatabaseWriter (could be GRDB.DatabaseQueue, GRDB.DatabasePool, or a test mock). The private let guarantees immutability, which is critical for Swift 6 concurrency safety (makes Exporter Sendable)

Our repositories don't "provide" the DatabaseWriter - they consume it the same way Exporter does. Both take a DatabaseWriter via DI, but repositories encapsulate complex queries so other services don't have to write raw SQL. 

Why This Matters: If Exporter uses GoalRepository.fetchAll(), it automatically gets:

    JSON aggregation (fast 1-query pattern)
    Proper error handling (ValidationError conversion)
    All related data (expectations, measures, relevances)
    Future optimizations for free (if repository improves, exporter benefits)
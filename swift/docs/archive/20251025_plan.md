# thoughts

1. classes in swift should reflect natural hierachies, not merely shared behaviors as per Apple developer guidance
2. For Apple platforms, we're building with the UI in mind, very close to the data structures. Unlike python and js, where we first built our APIs to ensure that the data was correctly defined and flowing, here it is very easy to display data types. I don't know if this is a real difference or just a matter of my experiencing the ease of access to the ui elements. But it means we want to be intentional about how we layer and use viewmodels as a part of the core logic. I think I should rearchitect as follows:
   1. clarify the database schemas as I would my ontology
   2. define the protocols and classes that represent the general patterns, attributes, and behaviors of the models
   3. define the models in structs and classes
   4. extend protocols as appropriate for separation of concerns 
   5. define the viewmodel protocols and classes
3. I expect to break each part of the app as I do this.
4. This is a fine time to think again about how I test and what I test.
5. let''s remove inference entirely for now
6. the codebase audit from 10/24 says a lot I'm not ready to think about. However, I do want to hold on to accessibility and make it a priority before v 1.0.0
7. I'm not at all sure how to think about threading and concurrency.
8. make sure Values() is PersonalValue()

# Database Scehmata

## Core questions to answer:

  1. What relationships do you need to query?
    - "Show me all Actions that contribute to Goal X"
    - "Show me all Goals in Term Y"
    - "Show me Actions aligned with Value Z"
    - "What Values does Goal X serve?"
  2. What aggregations do you need?
    - "Sum all Action measurements (km) toward Goal target (120 km)"
    - "Show progress percentage for each Goal in current Term"
    - "Count Actions per Value/LifeDomain over time period"
  3. What hierarchies exist?
    - Are Values/MajorValues/HighestOrderValues really different types, or different priority levels of the
   same type?
    - Are Goal/Milestone really different types, or different configurations of the same type?
  4. What temporal queries matter?
    - "Actions logged in date range"
    - "Goals due in next 2 weeks"
    - "Terms that overlap with date X"

  Looking at your current schema problems:

  - 4 separate value tables (valueses, majorValueses, etc) with polymorphicSubtype - this makes "get all my
   values regardless of priority level" require UNION queries
  - No action_goal_relationships table - can't query "which goals does this action serve?"
  - No goal_value_alignments table - can't query "which values does this goal align with?"

  Before we design protocols, what are the top 5-10 queries you need to run regularly for the app to work?
  Let's start there.


### Answers

Action() are going to have the shape of frequently entered records. I'll want to query, aggregate, match, and make inferences about large batches of actions. I want actions to be structured in a way that's useful for tracking progress on goals and alignment with values. So it needs to be possible to sum, count, and do other statistics about actions. It needs to be possible to reason about their timing and their relationship to goals and values.
Between actions and goals there is a discussion of measures, and so far I've relied on dicts to enable arbitrary decisions about units. I now think it might be more appropirate to create an additional data structure in the form of metrics. Such that a relationship can be mapped between actions and metrics and both can be stored in their own records. This way it is possible to query all the actions with km (or even with distances if we add a type to the metric) without parsing a json for every single action... 
Goals() (need to revise plurals to singular to accomodate the @table which add 's' to the table name) and Values() are written less often, but they are an important part of the many to many schemata that will make the app not just a log, but an informative record of meaningful actions done and a supportive assist for how to make changes. If we were to manually queru the db right now, we would be able to glean some insights, but it wouldn't be obvious how to find them at a glance. I think it should be. And so the relationships need to enable that.
I don't know about polymorphism rightn ow. It was a learning exercise, but it might not be useful. I think an enum might be good enough to distinguish smart goals, goals, andother Completables. But between compeltable, doable, and motivating, I think we could condense. The main thing is that actions, values, goals, smartgoals, high level values have some things in common, about all of those I can ask some similar questions. But maybe a field in the db is sufficient to distinguish goals and smart goals.... It will matter in the display and in the logic- I want a smartgoal to have additional features,. I want it to stand out as a core feature of my goal term. I want to be reminded of it, encouraged to think about it, etc. My highest order goals aren't actionable so I want them there just as a bit of furniture, a reminder, a beacon of sorts.




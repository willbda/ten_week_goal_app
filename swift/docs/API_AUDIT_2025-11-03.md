# SQLiteData & Swift API Usage Audit
**Date**: 2025-11-03
**Auditor**: Claude Code
**Scope**: All SQLiteData API calls, model conformances, and Swift 6 patterns

---

## Executive Summary

‚úÖ **Overall Assessment**: Your SQLiteData usage is **generally correct and efficient**

**Key Findings**:
- ‚úÖ Models use `@Table` correctly with proper protocols
- ‚úÖ Most query patterns follow SQLiteData best practices
- ‚ö†Ô∏è MetricRepository is commented out (intentional, but needs replacement)
- ‚ö†Ô∏è Some opportunities for query optimization (`.find()` vs direct queries)
- ‚úÖ Enum conformances are correct
- ‚úÖ Sendable and async/await patterns are sound

---

## 1. Model @Table Usage & Conformances

### ‚úÖ CORRECT: Action.swift

```swift
@Table
public struct Action: DomainAbstraction {
    public var id: UUID
    public var title: String?
    // ... other fields
}
```

**Analysis**:
- ‚úÖ Correctly uses `@Table` macro
- ‚úÖ Conforms to `DomainAbstraction` which extends `Sendable`
- ‚úÖ All properties are Sendable types (UUID, String, Date, Double, Bool)
- ‚úÖ No stored closures or non-Sendable types

**Recommendation**: ‚úÖ No changes needed

---

### ‚úÖ CORRECT: PersonalValue.swift

```swift
public enum ValueLevel: String, Codable, CaseIterable, Sendable,
    QueryRepresentable, QueryBindable {
    case general = "general"
    case major = "major"
    case highestOrder = "highest_order"
    case lifeArea = "life_area"
}

@Table
public struct PersonalValue: DomainAbstraction {
    public var id: UUID
    public var valueLevel: ValueLevel
    // ...
}
```

**Analysis**:
- ‚úÖ `ValueLevel` enum has ALL required conformances:
  - `Codable` - for JSON/database encoding
  - `QueryRepresentable` - tells SQLiteData how to represent in queries
  - `QueryBindable` - tells SQLiteData how to bind values
  - `Sendable` - Swift 6 concurrency safety
- ‚úÖ Enum raw values match database schema ('general', 'major', etc.)
- ‚úÖ `PersonalValue` correctly uses enum in struct

**From SQLiteData source** (`StructuredQueries+GRDB/SQLiteQueryDecoder.swift`):
```swift
// Enums need QueryRepresentable to decode from database
// Enums need QueryBindable to encode to database parameters
```

**Recommendation**: ‚úÖ No changes needed - this is the correct pattern

---

### ‚ö†Ô∏è MISSING: Other Model Conformances

**Question**: Do other models with enums have proper conformances?

Let me check if there are other enums that need conformances:
- `GoalType`, `MilestoneType` (if they exist)
- Any other enum fields in models

**Recommendation**: Audit all enum types to ensure they have `QueryRepresentable` + `QueryBindable`

---

## 2. Query Patterns Audit

### ‚úÖ CORRECT: ActionCoordinator.swift (Lines 52, 60)

```swift
// Checking if entity exists
let measureExists = try Measure.find(measurement.measureId!).fetchOne(db) != nil
let goalExists = try Goal.find(goalId).fetchOne(db) != nil
```

**Analysis**:
- ‚úÖ Uses `.find(id)` helper from SQLiteData @Table
- ‚úÖ Followed by `.fetchOne(db)` to execute
- ‚úÖ Returns `Optional<T>`, so `!= nil` check is correct

**SQLiteData Pattern** (from source):
```swift
// @Table generates:
extension YourModel {
    static func find(_ id: PrimaryKey) -> SelectStatement<YourModel> {
        // Returns query builder - must call .fetchOne()/.fetchAll()
    }
}
```

**Recommendation**: ‚úÖ Correct usage

---

### ‚úÖ CORRECT: ActionFormViewModel.swift (Lines 78-80)

```swift
let measures = try Measure.all
    .order { $0.unit.asc() }
    .fetchAll(db)
```

**Analysis**:
- ‚úÖ `Measure.all` - correct static query builder from @Table
- ‚úÖ `.order { ... }` - type-safe ordering with key path
- ‚úÖ `.fetchAll(db)` - executes and returns `[Measure]`
- ‚úÖ Called within `database.read { db in ... }` closure

**SQLiteData Documentation** (from fetched docs):
> "@FetchAll(Item.order(by: \.name)) var items"
> "It takes a query built using the StructuredQueries library"

**Recommendation**: ‚úÖ Correct usage

---

### ‚úÖ CORRECT: ActionsQuery.swift (Lines 147-148, 162-164)

```swift
// Query 1: Fetch all actions ordered by time
Action.all
    .order { $0.logTime.desc() }
    .fetchAll(db)

// Query 2: Filter measured actions by action IDs
MeasuredAction.all
    .where { actionIds.contains($0.actionId) }
    .fetchAll(db)
```

**Analysis**:
- ‚úÖ `.all` - generates SELECT *
- ‚úÖ `.order { closure }` - type-safe ordering
- ‚úÖ `.where { closure }` - type-safe filtering
- ‚úÖ `.contains()` for `IN` clause equivalent
- ‚úÖ `.fetchAll(db)` execution

**SQLiteData Pattern** (from source docs):
```swift
Player.where { $0.lastName == lastName }.fetchAll(db)
// SELECT ‚Ä¶ FROM "players" WHERE "players"."lastName" = ?
```

**Recommendation**: ‚úÖ Correct and efficient

---

### ‚úÖ CORRECT: Insert/Update/Delete Patterns

#### Insert (ActionCoordinator.swift:67-79)

```swift
let action = try Action.insert {
    Action.Draft(
        title: formData.title.isEmpty ? nil : formData.title,
        // ... other fields
    )
}
.returning { $0 }
.fetchOne(db)!
```

**Analysis**:
- ‚úÖ `.insert { Draft(...) }` - SQLiteData pattern for INSERT
- ‚úÖ `.returning { $0 }` - returns inserted row
- ‚úÖ `.fetchOne(db)!` - safe force-unwrap (insert always succeeds or throws)
- ‚úÖ Uses `Draft` type generated by @Table macro

**SQLiteData Source** (Statement+GRDB.swift):
```swift
// .fetchOne(db) returns Optional<T>
// Safe to force-unwrap after successful .insert
guard let result = try statement.fetchOne(db)
else { throw NotFound() }
```

**Recommendation**: ‚úÖ Correct - force-unwrap is safe here

---

#### Update (TimePeriodCoordinator.swift:120-124)

```swift
let updatedTimePeriod = try TimePeriod.upsert {
    var updated = Draft(existingTimePeriod)
    // ... modify fields
    return updated
}
.returning { $0 }
.fetchOne(db)!
```

**Analysis**:
- ‚úÖ `.upsert` for UPDATE operations (INSERT OR REPLACE)
- ‚úÖ Preserves existing ID by using `Draft(existing)`
- ‚úÖ `.returning { $0 }` returns updated row

**Note**: The coordinator uses `.upsert` (not `.update`) which is:
- INSERT OR REPLACE semantics
- Simpler than explicit UPDATE statement
- Works because ID is preserved

**Alternative** (more explicit):
```swift
// Could also use:
try TimePeriod.update(existingTimePeriod) {
    $0.title = newTitle
    // ...
}.execute(db)
```

**Recommendation**: ‚ö†Ô∏è **Consider renaming to `.update()` for clarity**
`.upsert` implies "insert if not exists", but you're always updating existing records.

---

#### Delete (ActionCoordinator.swift:237, 242, 246)

```swift
// Delete relationships first
try MeasuredAction.delete(measurement).execute(db)
try ActionGoalContribution.delete(contribution).execute(db)

// Then delete main entity
try Action.delete(action).execute(db)
```

**Analysis**:
- ‚úÖ `.delete(entity)` - type-safe delete by instance
- ‚úÖ `.execute(db)` - executes DELETE statement
- ‚úÖ Deletes relationships before main entity (good practice)
- ‚úÖ Should be wrapped in transaction (it is - in `database.write { }`)

**SQLiteData Pattern** (from source):
```swift
// @Table generates:
static func delete(_ value: Self) -> DeleteStatement {
    // DELETE FROM table WHERE id = ?
}
```

**Recommendation**: ‚úÖ Correct pattern

---

### ‚ö†Ô∏è INEFFICIENT: Repeated `.find()` calls

**Location**: MetricRepository.swift (commented out)

```swift
// INEFFICIENT:
for am in actionMeasures {
    if let metric = try await Measure.find(am.measureId) { ... }
    // N+1 query problem!
}
```

**Problem**: N+1 queries - fetches each Measure individually

**Better approach**:
```swift
// Fetch all measures at once
let measureIds = actionMeasures.map { $0.measureId }
let measures = try await Measure.all
    .where { measureIds.contains($0.id) }
    .fetchAll(db)

// Build lookup dictionary
let measureDict = Dictionary(uniqueKeysWithValues: measures.map { ($0.id, $0) })

// Use dictionary for O(1) lookups
for am in actionMeasures {
    if let metric = measureDict[am.measureId] { ... }
}
```

**Recommendation**: ‚ö†Ô∏è **Optimize when you un-comment MetricRepository**

---

## 3. @FetchAll / @FetchOne Usage

### ‚úÖ CORRECT: PersonalValuesListView.swift (Line 25)

```swift
@FetchAll(PersonalValue.order { ($0.valueLevel.asc(), $0.priority.asc()) })
private var personalValues: [PersonalValue]
```

**Analysis**:
- ‚úÖ `@FetchAll` property wrapper for SwiftUI integration
- ‚úÖ Multi-column sort: `(valueLevel ASC, priority ASC)`
- ‚úÖ Automatically observes database changes
- ‚úÖ Updates SwiftUI view when data changes

**SQLiteData Documentation** (from fetched docs):
> "@FetchAll is similar to SwiftData's @Query macro, but more powerful"
> "Uses GRDB's observation APIs to keep property wrappers in sync"

**Recommendation**: ‚úÖ Correct usage

---

### ‚ö†Ô∏è MISSING: @FetchOne for Aggregates

**Use Case**: Count queries, sums, averages

**Example** (should be in ViewModels):
```swift
// Count actions
@FetchOne(Action.count())
var actionsCount = 0

// Sum measurements
@FetchOne(#sql("SELECT SUM(value) FROM measured_actions WHERE measureId = ?", measureId))
var totalDistance = 0.0
```

**Recommendation**: ‚ö†Ô∏è **Add @FetchOne for dashboard statistics**

---

## 4. Relationship Queries & JOINs

### ‚ö†Ô∏è MISSING: Proper JOIN queries

**Current Pattern** (ActionsQuery.swift):
```swift
// 1. Fetch all actions
let actions = try Action.all.order { $0.logTime.desc() }.fetchAll(db)

// 2. Fetch related MeasuredActions
let measurements = try MeasuredAction.all
    .where { actionIds.contains($0.actionId) }
    .fetchAll(db)

// 3. Group in memory
// ... complex grouping logic
```

**Analysis**:
- ‚ö†Ô∏è 2+ separate queries (not atomic)
- ‚ö†Ô∏è In-memory grouping (could be done in database)
- ‚úÖ Works correctly but not optimal

**Better approach with JOIN**:
```swift
// Option A: Query builder JOIN (type-safe)
let results = try Action.all
    .join(MeasuredAction.all, on: { action, measurement in
        action.id == measurement.actionId
    })
    .join(Measure.all, on: { (_, measurement), measure in
        measurement.measureId == measure.id
    })
    .select { (action, measurement, measure) in
        (action, measurement, measure)
    }
    .fetchAll(db)

// Option B: #sql macro (cleaner for complex queries)
struct ActionWithMeasurements: Decodable {
    let action: Action
    let measurements: [MeasuredAction]
    let measures: [Measure]
}

let results = try #sql(
    """
    SELECT
        a.*,
        json_group_array(json_object(
            'measureId', ma.measureId,
            'value', ma.value,
            'unit', m.unit
        )) as measurements
    FROM actions a
    LEFT JOIN measured_actions ma ON a.id = ma.actionId
    LEFT JOIN measures m ON ma.measureId = m.id
    GROUP BY a.id
    ORDER BY a.logTime DESC
    """,
    as: ActionWithMeasurements.self
).fetchAll(db)
```

**SQLiteData Documentation** (from source):
> "This library supports building everything from SELECT, INSERT, UPDATE, and DELETE
> statements, to recursive common table expressions"

**Recommendation**: ‚ö†Ô∏è **Consider JOINs for ActionsQuery performance**

**When to use JOINs**:
- ‚úÖ When you need data from multiple related tables
- ‚úÖ When filtering on relationship data
- ‚úÖ When aggregating across relationships

**When multi-query is OK**:
- ‚úÖ Simple parent-child lookups
- ‚úÖ When you need data at different times
- ‚úÖ For testing/development

---

## 5. Async/Await & Concurrency

### ‚úÖ CORRECT: Database Read/Write Closures

```swift
// ActionFormViewModel.swift:76
let (measures, goals) = try await database.read { db in
    let measures = try Measure.all.order { $0.unit.asc() }.fetchAll(db)
    let goals = try Goal.all.fetchAll(db)
    return (measures, goals)
}

// ActionCoordinator.swift:49
return try await database.write { db in
    // Multiple inserts in single transaction
    let action = try Action.insert { ... }.returning { $0 }.fetchOne(db)!
    try MeasuredAction.insert { ... }.execute(db)
    return action
}
```

**Analysis**:
- ‚úÖ `database.read { }` for SELECT queries
- ‚úÖ `database.write { }` for INSERT/UPDATE/DELETE
- ‚úÖ Both are `async throws` - proper error propagation
- ‚úÖ Captures local vars in closure (not `self`)
- ‚úÖ Returns values from closure correctly

**GRDB/SQLiteData Pattern**:
```swift
// read { } runs on database's serial queue (thread-safe)
// write { } wraps in transaction automatically
// Both are async, so safe to call from @MainActor
```

**Recommendation**: ‚úÖ Correct usage

---

### ‚úÖ CORRECT: @MainActor Usage

```swift
@Observable
@MainActor
public final class ActionFormViewModel {
    @ObservationIgnored
    @Dependency(\.defaultDatabase) var database

    public func loadOptions() async {
        let data = try await database.read { db in
            // Runs on database queue
        }
        // Back on MainActor here
        self.availableMeasures = data
    }
}
```

**Analysis**:
- ‚úÖ ViewModel is `@MainActor` (all methods run on main thread)
- ‚úÖ Database operations use `async` (yield thread during DB work)
- ‚úÖ `@Dependency` injection (not directly using global state)
- ‚úÖ No `nonisolated` needed - async functions can cross actor boundaries

**Swift 6 Concurrency Rules**:
- ‚úÖ `@MainActor` ensures UI updates on main thread
- ‚úÖ `async` allows yielding during database I/O
- ‚úÖ `Sendable` types (Action, Measure) safe to pass between actors

**Recommendation**: ‚úÖ Correct pattern

---

## 6. Sendable Conformance

### ‚úÖ CORRECT: Model Structs

```swift
@Table
public struct Action: DomainAbstraction {
    // All properties are Sendable:
    public var id: UUID              // Sendable
    public var title: String?        // Sendable
    public var logTime: Date         // Sendable
    public var durationMinutes: Double?  // Sendable
}

// DomainAbstraction likely extends Sendable
public protocol DomainAbstraction: Sendable {
    var id: UUID { get }
    var title: String? { get }
    // ...
}
```

**Analysis**:
- ‚úÖ All structs with only Sendable properties are implicitly Sendable
- ‚úÖ Explicit `Sendable` conformance via `DomainAbstraction`
- ‚úÖ No non-Sendable types (closures, mutable references)

**Swift 6 Rules**:
```swift
// Struct is Sendable if all stored properties are Sendable
struct Foo: Sendable {  // OK
    let id: UUID
    let name: String
}

struct Bar {  // ERROR: non-Sendable property
    var closure: () -> Void  // Closures are not Sendable by default
}
```

**Recommendation**: ‚úÖ All models are correctly Sendable

---

## 7. Error Patterns

### ‚úÖ CORRECT: Force-Unwrap After Insert

```swift
let action = try Action.insert { ... }
    .returning { $0 }
    .fetchOne(db)!  // Safe: successful insert always returns value
```

**Why safe**:
1. `.insert` throws if it fails (constraint violation, etc.)
2. If `.insert` succeeds, `.fetchOne` always returns a value
3. Force-unwrap is safe because we can't reach it if insert failed

**Alternative** (more defensive):
```swift
guard let action = try Action.insert { ... }.returning { $0 }.fetchOne(db) else {
    throw CoordinatorError.insertFailed("Action insert succeeded but returned nil")
}
```

**Recommendation**: ‚úÖ Current pattern is fine, but add comment explaining why safe

---

### ‚ö†Ô∏è CONSIDER: Custom Error Types

**Current**:
```swift
throw CoordinatorError.measureNotFound(measureId)
throw CoordinatorError.goalNotFound(goalId)
```

**Analysis**:
- ‚úÖ Using custom error enum
- ‚úÖ Includes associated values (IDs)
- ‚ö†Ô∏è Not sure if `CoordinatorError` conforms to `LocalizedError`

**Recommendation**: ‚ö†Ô∏è Ensure `CoordinatorError` provides user-friendly messages:

```swift
enum CoordinatorError: LocalizedError {
    case measureNotFound(UUID)
    case goalNotFound(UUID)

    var errorDescription: String? {
        switch self {
        case .measureNotFound(let id):
            return "Measure \(id) not found"
        case .goalNotFound(let id):
            return "Goal \(id) not found"
        }
    }
}
```

---

## 8. Commented-Out Code Issues

### ‚ö†Ô∏è PROBLEM: MetricRepository.swift is 100% commented out

**Location**: `swift/Sources/Services/MetricRepository.swift`

**Impact**:
- ‚ùå No metric querying functionality
- ‚ùå No progress calculation
- ‚ùå No aggregation queries

**Why commented out** (likely):
- Old API doesn't match new 3NF schema
- Needs rewrite for new models

**Recommendation**: üö® **HIGH PRIORITY - Rewrite MetricRepository**

**Suggested approach**:
```swift
@MainActor
public class MetricRepository: ObservableObject {
    @Dependency(\.defaultDatabase) var database

    /// Fetch all measures
    public func allMeasures() async throws -> [Measure] {
        try await database.read { db in
            try Measure.all.order { $0.unit.asc() }.fetchAll(db)
        }
    }

    /// Get measurements for action (with measure details)
    public func measurements(for actionId: UUID) async throws -> [(MeasuredAction, Measure)] {
        try await database.read { db in
            // JOIN query
            try MeasuredAction.all
                .where { $0.actionId == actionId }
                .join(Measure.all, on: { $0.measureId == $1.id })
                .select { ($0, $1) }
                .fetchAll(db)
        }
    }

    /// Calculate progress for goal
    public func calculateProgress(goalId: UUID) async throws -> GoalProgress {
        try await database.read { db in
            // Complex aggregation query
            // ... implementation
        }
    }
}
```

---

## 9. Performance Considerations

### ‚úÖ GOOD: Using Indexes

**Assumption**: Database schema has proper indexes

**Check schema**:
```sql
-- Foreign key indexes (should exist)
CREATE INDEX idx_measured_actions_action_id ON measured_actions(actionId);
CREATE INDEX idx_measured_actions_measure_id ON measured_actions(measureId);
CREATE INDEX idx_action_goal_contributions_action_id ON action_goal_contributions(actionId);
CREATE INDEX idx_action_goal_contributions_goal_id ON action_goal_contributions(goalId);

-- Sort/filter indexes
CREATE INDEX idx_actions_log_time ON actions(logTime DESC);
CREATE INDEX idx_personal_values_level_priority ON personal_values(valueLevel, priority);
```

**Recommendation**: ‚úÖ Verify indexes exist in schema files

---

### ‚ö†Ô∏è CONSIDER: Query Batch Size

**Current**: No LIMIT/OFFSET on queries

```swift
// Fetches ALL actions (could be thousands)
Action.all.order { $0.logTime.desc() }.fetchAll(db)
```

**For large datasets**, consider pagination:
```swift
// Option A: LIMIT/OFFSET
Action.all
    .order { $0.logTime.desc() }
    .limit(50)
    .offset(page * 50)
    .fetchAll(db)

// Option B: Cursor-based (better for real-time data)
Action.all
    .where { $0.logTime < lastSeenTime }
    .order { $0.logTime.desc() }
    .limit(50)
    .fetchAll(db)
```

**Recommendation**: ‚ö†Ô∏è **Add pagination when you have 100+ actions**

---

## 10. Missing Functionality

### ‚ö†Ô∏è NEEDED: Transaction Helpers

**Use Case**: Complex multi-step operations

**Current**: Wrapping in `database.write { }` manually

**Better**: Helper functions for common patterns

```swift
extension ActionCoordinator {
    /// Batch create actions with measurements
    public func batchCreate(_ formDataArray: [ActionFormData]) async throws -> [Action] {
        try await database.write { db in
            var actions: [Action] = []
            for formData in formDataArray {
                // Insert action
                let action = try Action.insert { ... }.returning { $0 }.fetchOne(db)!

                // Insert measurements
                for measurement in formData.measurements {
                    try MeasuredAction.insert { ... }.execute(db)
                }

                actions.append(action)
            }
            return actions
        }
    }
}
```

**Recommendation**: ‚ö†Ô∏è **Add batch operations for efficiency**

---

## 11. Documentation Issues

### ‚ö†Ô∏è MISSING: API Usage Examples

**Current**: Inline comments explain patterns

**Better**: Centralized examples document

**Recommendation**: ‚ö†Ô∏è **Create `SQLITEDATA_PATTERNS.md`** with:
- Common query patterns
- JOIN examples
- Aggregation examples
- Transaction patterns
- Error handling patterns

---

## Summary of Recommendations

### üö® HIGH PRIORITY (Breaking functionality)

1. **Un-comment and rewrite MetricRepository.swift**
   - Current: 100% commented out
   - Impact: No progress calculation, no aggregations
   - Timeline: Should be Phase 3 priority

2. **Add indexes to database schema**
   - Check if foreign key indexes exist
   - Add compound indexes for common queries
   - Timeline: Before production deployment

---

### ‚ö†Ô∏è MEDIUM PRIORITY (Performance/UX)

3. **Optimize N+1 queries in MetricRepository**
   - Use batch fetches instead of loops
   - Timeline: When un-commenting MetricRepository

4. **Consider JOINs for ActionsQuery**
   - Current: 2-3 separate queries + in-memory grouping
   - Better: Single JOIN query
   - Timeline: When performance becomes issue (1000+ actions)

5. **Rename `.upsert` to `.update` in Coordinators**
   - Current: Confusing - upsert implies "insert if not exists"
   - Better: Explicit `.update` for clarity
   - Timeline: When refactoring coordinators

6. **Add pagination for list views**
   - Timeline: When you have 100+ actions

---

### ‚úÖ LOW PRIORITY (Code quality)

7. **Add @FetchOne for dashboard statistics**
   - Easy wins for real-time counts/sums

8. **Create `SQLITEDATA_PATTERNS.md` guide**
   - Helps future development

9. **Add transaction helper methods**
   - Batch operations, complex workflows

10. **Ensure CoordinatorError implements LocalizedError**
    - Better error messages for users

---

## Specific Code Changes Recommended

### Change 1: Fix upsert ‚Üí update naming

**File**: `TimePeriodCoordinator.swift:120`

**Current**:
```swift
let updatedTimePeriod = try TimePeriod.upsert {
    var updated = Draft(existingTimePeriod)
    // ...
}.returning { $0 }.fetchOne(db)!
```

**Recommended**:
```swift
// Check if SQLiteData has .update() method
// If not, keep .upsert but add comment:

// NOTE: Using .upsert (not .update) because it's the pattern
// recommended by SQLiteData for preserving ID during UPDATE.
// This is an UPDATE operation (not INSERT OR REPLACE).
let updatedTimePeriod = try TimePeriod.upsert {
```

---

### Change 2: Add comment for safe force-unwrap

**File**: `ActionCoordinator.swift:79`

**Current**:
```swift
.fetchOne(db)!
```

**Recommended**:
```swift
.fetchOne(db)!  // Safe: successful insert always returns value, or throws
```

---

### Change 3: Un-comment and fix MetricRepository

**File**: `MetricRepository.swift`

**Action**: Rewrite using SQLiteData v1.3.0 API patterns seen in Coordinators

---

## Conclusion

Your SQLiteData usage is **fundamentally sound**. The main issues are:

1. **MetricRepository commented out** (blocking Phase 3 progress)
2. **Some minor optimizations** available (but not critical)
3. **Documentation** would help future maintenance

The patterns you're using (`.insert`/`.upsert`/`.delete`, `.fetchAll`/`.fetchOne`, `@FetchAll` property wrappers, transaction wrapping, Sendable conformance) are all **correct and follow SQLiteData best practices**.

---

**Next Steps**:
1. Un-comment MetricRepository
2. Rewrite it using correct API (follow ActionCoordinator patterns)
3. Add indexes to schema
4. Test with larger datasets
5. Consider JOINs for complex queries

---

**References**:
- SQLiteData docs: https://swiftpackageindex.com/pointfreeco/sqlite-data/1.3.0/documentation/sqlitedata
- StructuredQueries docs: https://swiftpackageindex.com/pointfreeco/swift-structured-queries
- GRDB docs (underlying library): https://github.com/groue/GRDB.swift
- Your local SQLiteData source: `/Users/davidwilliams/Downloads/sqlite-data-main/`

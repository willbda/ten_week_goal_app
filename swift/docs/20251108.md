# Development Roadmap & Technical Questions
## Session Notes: November 8, 2025

This document organizes open questions, implementation plans, and design considerations for the Ten Week Goal App as of v0.6.0.

---

## Table of Contents

1. [Database & Performance](#database--performance)
2. [Repository & Service Layer](#repository--service-layer)
3. [Apple Platform Integration](#apple-platform-integration)
4. [Architecture & Design](#architecture--design)
5. [User Experience](#user-experience)
6. [Foundation Model Integration](#foundation-model-integration)
7. [Development Roadmap](#development-roadmap)
8. [Success Criteria](#success-criteria)

---

## Database & Performance

### Current Status: Database Indexes

**Question**: Do we have all the indices we need for efficient queries?

**Answer**: Yes, we have 16 performance indexes implemented in `schema_current.sql`:
- `idx_measured_actions_action_id` - For action measurement lookups
- `idx_action_goal_contributions_action_id` - For action-goal relationships
- `idx_action_goal_contributions_goal_id` - For goal progress queries
- `idx_term_goal_assignments_term_id` - For term-based queries
- `idx_goal_relevances_goal_id` - For value alignment lookups
- Plus indexes for FKs and common query patterns

**Evidence**: The ActionsQuery optimization went from 763 queries → 3 queries (800ms → 50ms) thanks to these indexes.

**Action Item**: Monitor query performance as we add dashboard features. May need composite indexes for complex aggregations.

### Database Read Efficiency

**Question**: Are database reads set up for efficiency? What will support scaling?

**Current Approach**:
- ✅ Using SQLiteData's structured query builders (type-safe)
- ✅ Bulk queries with `WHERE id IN (...)` pattern
- ✅ In-memory grouping after fetch (Dictionary grouping)
- ⏳ Planning migration to `#sql` macros for complex aggregations

**Scaling Strategy**:
1. **Immediate**: Indexes + bulk queries (current, working well)
2. **Phase 4**: Add validation layer to catch bad queries early
3. **Post-v1.0**: Migrate to `#sql` macros for dashboard aggregations
4. **Future**: Consider read replicas if needed (unlikely for single-user app)

**Trade-offs**:
- Current: Safer (compile-time checks), slightly slower
- Future: Faster (database-side aggregation), runtime errors possible

### Database Philosophy

**Question**: SQL/SQLite is fast and efficient; the database should do heavy lifting, balanced for maintainability. Is that right?

**Answer**: Yes, with nuance:

**Database SHOULD do**:
- Filtering (WHERE clauses)
- Sorting (ORDER BY)
- Joins (normalized relationships)
- Aggregations (COUNT, SUM, AVG) - especially for dashboard
- Enforcing constraints (FK, NOT NULL, CHECK)

**Application layer SHOULD do**:
- Business logic validation (before insert)
- Complex calculations requiring Swift types
- Transforming database results into view models
- Error mapping (DB errors → user-friendly messages)

**Current Balance**: Good. We use SQLiteData's query builders (database-side filtering/sorting) but do complex assembly in Swift where type safety matters.

### SQLiteData API Usage

**Question**: Are we using SQLiteData APIs correctly? Insert vs. Upsert?

**Current Usage**:
```swift
// We use .insert() for new records (correct)
let goal = try Goal.insert {
    Goal.Draft(id: UUID(), ...)
}.returning { $0 }.fetchOne(db)!

// We DON'T use upsert currently
```

**Answer**:
- ✅ Using `.insert()` correctly for new records
- ✅ CloudKit sync is already configured via SQLiteData's `SyncEngine` (see DatabaseBootstrap.swift:115-135)
- ✅ Schema designed for CloudKit compatibility (UNIQUE constraints removed from junction tables)
- ⏳ May need `.upsert()` for update operations to handle offline sync conflicts

**Current Implementation**:
- SyncEngine syncs all 14 tables to CloudKit automatically
- UNIQUE constraints removed from junction tables to prevent sync conflicts
- Deduplication handled at application layer (planned for repositories)

---

## Repository & Service Layer

### MetricRepository Status

**Question**: What is the status of MetricRepository? What do we expect it to do?

**Current State**:
- ✅ Basic version exists at `Sources/Services/MetricRepository.swift`
- ✅ Provides CRUD for Measure entities
- ⏳ Lacks conversion support (e.g., km ↔ miles)

**Planned Responsibilities**:
1. Manage Measure catalog (create, read, update, delete)
2. Convert between units (using `conversionFactor` field)
3. Validate measurement values (e.g., no negative durations)
4. Provide common measures (hours, km, pages, etc.)

**Priority**: Medium (works for current needs, enhance when adding analytics)

### Core Repositories Needed

#### Priority 1: ActionRepository

**Why**: MatchingService is broken due to removed `measuresByUnit` field

**Planned Interface**:
```swift
class ActionRepository {
    func create(action: Action, metrics: [(Measure, Double)]) async throws
    func findWithMetrics(id: UUID) async throws -> ActionWithDetails
    func findByMeasure(measure: Measure, dateRange: DateRange?) async throws -> [Action]
    func sumByMeasure(measure: Measure, dateRange: DateRange) async throws -> Double
    func existsByTitle(title: String) async throws -> Bool  // Duplicate detection
}
```

**Status**: Scaffolded in `Sources/Services/Repositories/ActionRepository.swift`

#### Priority 2: GoalRepository

**Why**: Enable value-based queries and duplicate detection

**Planned Interface**:
```swift
class GoalRepository {
    func create(goal: Goal, targets: [(Measure, Double)], values: [PersonalValue]) async throws
    func findWithProgress(id: UUID) async throws -> GoalWithDetails
    func findByTerm(term: GoalTerm) async throws -> [Goal]
    func findByValue(value: PersonalValue) async throws -> [Goal]
    func existsByTitle(title: String) async throws -> Bool
}
```

**Status**: Scaffolded in `Sources/Services/Repositories/GoalRepository.swift`

#### Priority 3: ValueRepository

**Planned Interface**:
```swift
class ValueRepository {
    func findByLevel(level: ValueLevel) async throws -> [PersonalValue]
    func findAlignedGoals(value: PersonalValue) async throws -> [Goal]
    func calculateAlignment(action: Action) async throws -> [ValueAlignment]
}
```

**Status**: Scaffolded

### Business Services Needed

#### ProgressCalculationService

**Purpose**: Replace removed `isSmart()` method, calculate progress across metrics

```swift
class ProgressCalculationService {
    func calculateGoalProgress(goal: Goal) async throws -> Progress
    func calculateTermProgress(term: GoalTerm) async throws -> TermProgress
    func projectCompletion(goal: Goal) async throws -> Date?
}
```

**Why needed**: Dashboard will need aggregated progress metrics

#### AlignmentService

**Purpose**: Replace broken MatchingService

```swift
class AlignmentService {
    func scoreActionValueAlignment(action: Action, value: PersonalValue) async throws -> Double
    func suggestValuesForGoal(goal: Goal) async throws -> [PersonalValue]
    func findMisalignedGoals() async throws -> [Goal]
}
```

**Why needed**: Help users ensure goals align with values

#### MetricAggregationService

**Purpose**: Enable analytics and trend visualization

```swift
class MetricAggregationService {
    func dailyTotals(measure: Measure) async throws -> [DayTotal]
    func weeklyAverages(measure: Measure) async throws -> [WeekAverage]
    func trends(measure: Measure) async throws -> Trend
}
```

**Why needed**: Dashboard charts and insights

---

## Apple Platform Integration

### HealthKit Lessons Learned

**Question**: What lessons have we learned about importing from Apple HealthKit?

**Lessons**:

1. **Permissions are challenging but now working**
   - ✅ We have read permissions for workouts, sleep, mindfulness
   - ⚠️  Need to be specific about what data we request (don't ask for everything)

2. **Be particular, not general**
   - Focus on specific use cases: daily calories, sleep hours, meditation minutes
   - Don't try to ingest all available data (e.g., detailed stride/cadence for runs)
   - Evolve methodically as use cases emerge

3. **Staging table is designed but not wired**
   - ✅ `appledata` table exists for raw JSON storage
   - ❌ No code currently inserts into it
   - **Intended flow**: HealthKit → `appledata` (raw JSON) → parse → Action entities → delete staging data
   - **Benefit**: Allows "data archaeology" - reprocess with improved parsing logic later

4. **Current vs. Ideal Approach**:
   - **Current**: HealthKit data → directly to Action entities
   - **Ideal**: HealthKit data → `appledata` staging → inspect → parse → Actions
   - **Why ideal is better**: Preserve raw data, inspect before committing, retroactive parsing

5. **Next Steps**:
   - Read HealthKit/EventKit docs thoroughly
   - Understand Apple's expected access patterns
   - Wire up `appledata` staging table for new imports
   - Consider which granular data is actually useful (avoid data hoarding)

**References**:
- [Reading HealthKit Data](https://developer.apple.com/documentation/healthkit/reading-data-from-healthkit)
- [Querying Sleep Data](https://developer.apple.com/documentation/healthkit/about-the-healthkit-framework)

### Startup Performance

**Question**: Why does the application show a blank screen for several moments on startup? Can we use async loading?

**Investigation Needed**:
1. Profile startup sequence to identify bottleneck
2. Check if database queries are blocking main thread
3. Consider lazy loading or progressive rendering
4. Use SwiftUI's `.task` for async data loading
5. Show skeleton views or loading states

**Hypothesis**: Database initialization or initial @Fetch queries may be synchronous

**Action Item**: Add performance logging to startup sequence

### Sleep Prevention

**Question**: The application doesn't seem to allow sleeping. Is there a setting?

**Investigation Needed**:
- Check Info.plist for `UIApplicationExitsOnSuspend`
- Verify no background modes are preventing sleep
- Check for keep-alive timers or background tasks

**Expected**: App should allow device sleep unless actively tracking something

---

## Architecture & Design

### Entity Design Review

**Question**: Are our entities the right types? Are we using correct protocols? Abstracted too soon?

**Current Design Evaluation**:

✅ **Good Decisions**:
- Three-layer model (Abstraction/Basic/Composit) provides clear separation
- Trait-based protocols (Documentable, Timestamped) are honest about capabilities
- Sendable conformance for concurrency safety
- Using structs for immutable data, classes for coordinators/services

✅ **Correct Protocol Usage**:
- `DomainAbstraction: Identifiable + Documentable + Timestamped` (full metadata entities)
- `DomainBasic: Identifiable` (lightweight working entities)
- `DomainComposit: Identifiable` (junction tables)

⚠️  **Potential Over-Abstraction**:
- Expectation as discriminated union (goal/milestone/obligation) - time will tell if this was right
- May have abstracted Term too early (do we really need separate TimePeriod?)

✅ **Enum Usage**:
- `ExpectationType` as enum with CHECK constraint - good
- `ValueLevel`, `LifeDomain` as enums - appropriate

**Conclusion**: Design is solid. Minor over-abstraction won't hurt, and we can simplify later if needed.

### Error Handling

**Question**: Do we have error types that add clarity when custom functions/structs break?

**Current State**:
- ✅ `ValidationError` for business rule violations
- ✅ `CoordinatorError` for multi-model write failures
- ✅ `ConversationError` for LLM integration issues
- ⏳ Need repository-specific errors (e.g., `DuplicateEntityError`)

**Pattern**:
```swift
public enum ValidationError: Error, LocalizedError {
    case missingTitle
    case invalidDateRange(String)
    case duplicateEntity(String)

    public var errorDescription: String? {
        // User-friendly messages
    }
}
```

**Action Item**: Add repository error types as we implement repositories

### Dashboard Requirements

**Question**: What will we need for an efficient dashboard?

**Required Queries**:
1. **Progress Overview**: Goal completion percentage, actions completed this week
2. **Trends**: Metric totals over time (daily/weekly/monthly)
3. **Value Alignment**: Which values have most/least goal alignment
4. **Activity Heatmap**: Action frequency by day of week
5. **Upcoming Deadlines**: Goals approaching target dates

**Database Needs**:
- ✅ Indexes for date-range queries (have `idx_actions_log_time`)
- ⏳ Aggregation queries (likely need `#sql` macros)
- ⏳ Cached calculations (consider materialized views or periodic updates)

**Service Dependencies**:
- ProgressCalculationService
- MetricAggregationService
- AlignmentService

**Performance Target**: Dashboard should load in <200ms

---

## User Experience

### ViewModels Architecture

**Questions**:
1. Are ViewModels properly articulated for separation and maintainability?
2. Are we clear about entity/view/viewmodel relationships?
3. What viewmodels do we need for future features?

**Current State**:
- ✅ FormViewModels handle create/update/delete (ActionFormViewModel, GoalFormViewModel, etc.)
- ✅ ImportViewModels handle CSV import workflows
- ⏳ Missing: DashboardViewModel, AnalyticsViewModel, InsightsViewModel

**Pattern**:
```swift
@Observable
@MainActor
class FeatureViewModel {
    // State (auto-observed by @Observable)
    var isLoading = false
    var errorMessage: String?

    // Dependencies (not observed)
    @ObservationIgnored
    @Dependency(\.defaultDatabase) private var database

    // Methods (async for database ops)
    func performAction() async throws { }
}
```

**Needed ViewModels**:
- DashboardViewModel (aggregated metrics)
- AnalyticsViewModel (trends, charts)
- InsightsViewModel (LLM-powered suggestions)
- OnboardingViewModel (first-run experience)

### Design Language & UI

**Questions**:
1. How do we create and maintain a consistent design language?
2. What visuals make the app accessible, approachable, motivating?
3. How do we make it feel personalizable for others?

**Design Considerations**:

**Consistency**:
- Use SF Symbols throughout (standard Apple iconography)
- Define color palette (consider semantic colors for goal states)
- Establish spacing constants (8pt grid system)
- Standard component library (shared form components, buttons, cards)

**Accessibility & Approachability**:
- Gentle illustrations for empty states
- Progress indicators that feel encouraging (not judgmental)
- Color coding for goal types (aspirational vs. obligatory)
- Celebratory animations for milestones

**Personalization**:
- Custom color themes or app icons
- Personalized empty state messages
- User-defined value categories
- Flexible goal visualization (list vs. card vs. calendar view)

**SwiftUI Best Practices**:
- Use native controls when possible
- Follow HIG for navigation patterns
- Respect user accessibility settings (Dynamic Type, Reduce Motion)
- Test with VoiceOver

### Narrative & Onboarding

**Question**: Is it obvious what a "term" is? How do we make semantics more accessible?

**Problem**: "Term" and "ten-week cycle" may not be intuitive to new users

**Solutions**:
1. **Onboarding Flow**:
   - Explain: "A term is like a semester - a focused 10-week period for your goals"
   - Visual: Timeline showing how terms organize goals
   - Example: "Winter 2025 Term: Learn Spanish"

2. **Progressive Disclosure**:
   - Simple mode: Just goals (hide term complexity)
   - Advanced mode: Organize by terms
   - Let users discover terms gradually

3. **Alternative Naming**:
   - "Season" instead of "Term"?
   - "Sprint" for agile-familiar users?
   - "Focus Period"?

4. **In-App Help**:
   - Contextual tips on first use
   - "Why 10 weeks?" explainer
   - Examples of well-structured terms

**Action Item**: User test with non-technical friends/family

---

## Foundation Model Integration

### Vision

**Goal**: Make features programmatically accessible via structured APIs so LLMs can safely interact with app data.

**Use Cases**:
1. **Goal Setting Assistant**: "Help me set goals for the next ten weeks"
   - LLM asks questions about priorities
   - Generates structured goal proposals
   - User reviews and approves

2. **Progress Insights**: "How am I doing on my fitness goals?"
   - LLM queries repositories for relevant data
   - Generates natural language summary
   - Suggests adjustments

3. **Value Alignment Check**: "Are my goals aligned with my values?"
   - LLM analyzes goal-value relationships
   - Identifies gaps or misalignments
   - Suggests rebalancing

4. **Conversational Data Entry**: "I ran 5km this morning"
   - LLM extracts structured data (action: running, measure: 5km, time: morning)
   - Creates Action with measurements
   - Asks for confirmation

### Architecture Requirements

**Needed**:
- ✅ Structured APIs (coordinators provide this)
- ✅ Validation layer (in progress)
- ⏳ Function calling schema (define API as tools for LLM)
- ⏳ Safety layer (user approval for destructive actions)
- ⏳ Conversation context management

**Safety First**:
- Read-only queries can be automatic
- Writes require user approval
- Deletes always require explicit confirmation
- Show proposed changes before committing

**Foundation**:
- `ConversationHistory` entity already exists
- `ModelAvailability` checks for on-device models
- Need to implement actual LLM integration

---

## Development Roadmap

### Phase 4: Validation Layer (Current - v0.7.0)
**Goal**: Complete integration of validators with repositories

**Tasks**:
- [ ] Wire validators into repository layer
- [ ] Add duplicate detection (existsByTitle methods)
- [ ] Map database errors to ValidationErrors
- [ ] Test validation edge cases
- [ ] Document validation rules

### Phase 5-6: ViewModels & Views Audit (v0.8.0)
**Goal**: Ensure all ViewModels use modern patterns and Views are consistent

**ViewModels**:
- [ ] Audit all ViewModels for @Observable compliance
- [ ] Remove any lingering ObservableObject usage
- [ ] Add missing ViewModels (Dashboard, Analytics, Insights)
- [ ] Document ViewModel responsibilities

**Views & Visual System**:
- [ ] Implement Liquid Glass visual system (see `LIQUID_GLASS_VISUAL_SYSTEM.md`)
- [ ] Phase 1: Remove blur/opacity patterns, establish rich backgrounds
- [ ] Phase 2: Implement contextual background selection
- [ ] Phase 3: Apply `.glassEffect()` to custom controls
- [ ] Phase 4: Create immersive experiences with `.clear` variant
- [ ] Create component library following three-layer hierarchy
- [ ] Add empty states and loading states
- [ ] Implement accessibility features
- [ ] Add onboarding flow

### Phase 7: Testing & Polish (v0.9.0)
**Goal**: Comprehensive testing and performance optimization

**Testing**:
- [ ] Write integration tests for critical flows
- [ ] Add UI tests for key interactions
- [ ] Performance profiling and optimization
- [ ] Memory leak detection
- [ ] Test on all platforms (iOS, macOS, visionOS)

**Polish**:
- [ ] Animations and transitions
- [ ] Haptic feedback
- [ ] Error messages review
- [ ] Icon and asset refinement

### Phase 8: Platform Integration (v1.0.0)
**Goal**: Full Apple platform integration

**Features**:
- [x] CloudKit sync (implemented via SQLiteData SyncEngine) ✅
- [ ] HealthKit live tracking (wire up staging table)
- [ ] EventKit calendar sync
- [ ] Widgets and complications
- [ ] Shortcuts and App Intents

### Post-v1.0: Advanced Features
**Future**:
- [ ] LLM-powered insights (Foundation Model integration)
- [ ] Dashboard with charts and trends
- [ ] Social features (share goals, accountability partners)
- [ ] Export/backup to common formats
- [ ] Web companion app

---

## Success Criteria

### Phase Completion Checklist

- [x] **Phase 1-2**: All models compile without errors ✅
- [x] **Phase 3**: Coordinators handle multi-model writes ✅
- [ ] **Phase 4**: Validation layer enforces business rules
- [ ] **Phase 5**: Repositories provide clean query APIs
- [ ] **Phase 6**: ViewModels use modern @Observable pattern
- [ ] **Phase 7**: Views display normalized data correctly
- [ ] **Phase 8**: Performance meets targets (<200ms for common operations)
- [ ] **Phase 8**: Accessibility standards met (VoiceOver, Dynamic Type, etc.)
- [ ] **v1.0**: All platform integrations working (HealthKit, EventKit, Widgets)

### Quality Metrics

**Performance**:
- Dashboard load: <200ms
- List views: <100ms
- Database writes: <50ms
- App launch: <2 seconds

**Reliability**:
- Zero crashes in normal usage
- Graceful degradation when services unavailable
- Data integrity maintained (FK constraints, validation)
- Proper error messages for all failure modes

**Accessibility**:
- Full VoiceOver support
- Dynamic Type at all sizes
- Sufficient color contrast (WCAG AA)
- Keyboard navigation support (macOS)

---

## References

### Apple Documentation
- [Reading HealthKit Data](https://developer.apple.com/documentation/healthkit/reading-data-from-healthkit)
- [Querying Sleep Data](https://developer.apple.com/documentation/healthkit/about-the-healthkit-framework)
- [EventKit Best Practices](https://developer.apple.com/documentation/eventkit)
- [Human Interface Guidelines](https://developer.apple.com/design/human-interface-guidelines)

### SQLiteData & Dependencies
- [SQLiteData Documentation](https://swiftpackageindex.com/pointfreeco/sqlite-data/main/documentation/sqlitedata)
- [SQLiteData Reminders Example](https://github.com/pointfreeco/sqlite-data/tree/main/Examples/Reminders)
- [StructuredQueries Documentation](https://swiftpackageindex.com/pointfreeco/swift-structured-queries/main/documentation/structuredqueriescore)
- [GRDB Documentation](https://github.com/groue/GRDB.swift)

---

**Last Updated**: November 8, 2025
**Current Version**: v0.6.0
**Next Milestone**: v0.7.0 - Validation Layer Complete



# Questions

1. What is the status of our db indexes? Do we have all the indices we need for efficient queries?
2. Are database reads set up for efficiency? And what will support scaling? Indexes, sort orders, #sql macros, something else?
3. SQL/SQLite is fast, efficient, and reliable; the database should do as much of the heavy lifting as possible, balanced for maintanability and separation of concerns. Is that right and what should we do about it?
4. What is the status of the MetricReposity now? What do we expect it to do and are those plans in place? Do we understand them?
5. Are our entities broadly speaking of the right types? Are we using the correct protocols? Are we using enums correctly? Are there areas where we've abstracted too soon?
6. Do we have error types that add clarity around custom functions / structs that break?
7. What will we need for an efficient dashboard?
8. What will we need for LLM / Foundation Model tooling? 
   1. What use cases do we have in mind?
9. Are we using SQLiteDate APIs correcty
   1.  Upsert vs inster
10. What lessons have we learned about importing from Apple HealthKit?
    1.  It was challenging to get the permissions right, but we have them now and we can view some of the health data. It will be worthwhile to think more about which data is available and how to evolve methodically as we decide to ingest more data. It can be helpful to be particular rather than general, so we should focus on our specific use cases - tracking daily/weekly calories, tracking sleep hours, meditiation minutes... beyond that a lot feels enticing - sync with calendar, reminders, etc... 
    2.  the actual data is imported into the app via our actions struct. This is useful as a way of seeing what's possible, but maybe not the complete solution. We included a database table for apple data, but nothing hits it at present; it is not working as a staging area. It could. My aim was to extract something as close to the raw data as possible in the early stages so that we could inspect the data before making decisions about it. For runs, for instance, I suspect the data can be very fine grained (cadence, stride, etc.) and we might not know what to do with it
    3.  Using this data well will involve reading the docs and sdks to learn more about what data apple stores and how they expect for it to be accessed.
11. On startup the application shows a blank screen for several moments. Some questions: is there a startup process that is inefficient but then separately, are we able to use streaming and asycnronous loading to present a view? What exactly is loaded on start up?
12. The application doesn't seem to allow sleeping. Is there a setting somewhere that controls that?


# Roadmap

## Repositories

The coordinators handle **writes**, but we still need **query/read** optimization:

### Core Repositories Needed

#### Priority 1: ActionRepository
```swift
class ActionRepository {
    func create(action: Action, metrics: [(Metric, Double)]) async throws
    func findWithMetrics(id: UUID) async throws -> (Action, [MeasuredAction])
    func findByMetric(metric: Metric) async throws -> [Action]
    func sumByMetric(metric: Metric, dateRange: DateRange) async throws -> Double
}
```

**Why needed**: Currently broken - ActionsViewModel expects JSON measuresByUnit

#### Priority 2: GoalRepository
```swift
class GoalRepository {
    func create(goal: Goal, targets: [(Metric, Double)], values: [Value]) async throws
    func findWithProgress(id: UUID) async throws -> GoalWithProgress
    func findByTerm(term: Term) async throws -> [Goal]
    func findByValue(value: Value) async throws -> [Goal]
}
```

**Why needed**: GoalFormView references removed Goal fields, GoalsViewModel expects isSmart() method

#### Priority 3: ValueRepository
```swift
class ValueRepository {
    func findByLevel(level: ValueLevel) async throws -> [Value]
    func findAlignedGoals(value: Value) async throws -> [Goal]
    func calculateAlignment(action: Action) async throws -> [ValueAlignment]
}
```

**Why needed**: Enable value-based queries and alignment tracking

#### Completed: MetricRepository
- ✅ Basic version exists ([MetricRepository.swift](swift/Sources/App/Services/MetricRepository.swift))
- May need enhancement for conversion support

### Business Services Needed

#### ProgressCalculationService
```swift
class ProgressCalculationService {
    func calculateGoalProgress(goal: Goal) async throws -> Progress
    func calculateTermProgress(term: Term) async throws -> TermProgress
    func projectCompletion(goal: Goal) async throws -> Date?
}
```

**Why needed**: Replace removed isSmart() method, calculate progress across metrics

#### AlignmentService
```swift
class AlignmentService {
    func scoreActionValueAlignment(action: Action, value: Value) async throws -> Double
    func suggestValuesForGoal(goal: Goal) async throws -> [Value]
    func findMisalignedGoals() async throws -> [Goal]
}
```

**Why needed**: Replace MatchingService which is broken due to removed measuresByUnit

#### MetricAggregationService
```swift
class MetricAggregationService {
    func dailyTotals(metric: Metric) async throws -> [DayTotal]
    func weeklyAverages(metric: Metric) async throws -> [WeekAverage]
    func trends(metric: Metric) async throws -> Trend
}
```

**Why needed**: Enable analytics and trend visualization

## Validation


## ViewModels

1. Are these properly articulated for seperation and maintanability?
2. Are we clear about the relationship between entities, views, and viewmodels?
3. What viewmodels do we need to plan for as we work towards more features?


## Views and UI more generally

1. How do we create and maintain a consistent design language throughout?
2. What kind of art of comforting visuals do we want to include to make the application feel more accessible, approachable, or motivating?
3. What can we do to make the application feel more personal(izable)? If it's not just me but others using this to articulate goals, what would help others feel like it's their journey?
4. SwiftUI: use it... learn it, conform to the expectations so that we either don't break them or break them purposefully

## User experience - narrative

1. Is it obvious to anyone who is not me what a term is, why goals are framed in respect of terms? Possibly not. What can we do to make the semantics more accessible? How can we simplify the initial experience of the application and offer complexity?


## LLM / Foundation Model

I would like to have as much of the app as possible well structured so that most features are programmatically accessible via apis. This seems like a helpful heuristic generally, but then also it allows us to build toward using the llm to programmatically access those api with structured inputs. If this can be done safely, it might open the door to very very accessible features. Like "help me set goals for the next ten weeks" being the start to a facilitated experience.

## HIG and Accessibility

Reminder to think about it. 

# References

- [Reading HealthKit Data](https://developer.apple.com/documentation/healthkit/reading-data-from-healthkit)
- [Querying Sleep Data](https://developer.apple.com/documentation/healthkit/about-the-healthkit-framework)
- [EventKit Best Practices](https://developer.apple.com/documentation/eventkit)
- [SQLiteData Documentation](https://swiftpackageindex.com/pointfreeco/sqlite-data/main/documentation/sqlitedata)
- [SQLiteData Reminders Example](https://github.com/pointfreeco/sqlite-data/tree/main/Examples/Reminders)
- [StructuredQueries Documentation](https://swiftpackageindex.com/pointfreeco/swift-structured-queries/main/documentation/structuredqueriescore)
- [GRDB Documentation](https://github.com/groue/GRDB.swift)

# Criteria

## Success Criteria
- [x] All models compile without errors (Phase 1-2) ✅
- [x] Coordinators handle multi-model writes (Phase 3) ✅
- [ ] Validation layer enforces business rules (Phase 4)
- [ ] Protocols provide clean contracts (Phase 5)
- [ ] ViewModels handle relationships (Phase 6)
- [ ] Views display normalized data (Phase 7)
- [ ] Migration preserves all data (Phase 8)
- [ ] Performance meets or exceeds current (Phase 8)
- [ ] Accessibility standards met (Phase 8)
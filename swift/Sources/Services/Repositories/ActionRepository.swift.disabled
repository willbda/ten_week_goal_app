//
// ActionRepository.swift
// Written by Claude Code on 2025-11-09
//
// PURPOSE:
// Read coordinator for Action entities - centralizes query logic and existence checks.
// Uses #sql macros for complex queries while maintaining type safety through validation layer.
//
// RESPONSIBILITIES:
// 1. Read operations - fetchAll(), fetchByDateRange(), fetchByGoal()
// 2. Aggregations - totalByMeasure(), countByGoal() using #sql
// 3. Existence checks - exists() for duplicate prevention
// 4. Error mapping - DatabaseError â†’ ValidationError
//
// PATTERN:
// - Complex queries use #sql macros for performance
// - Simple queries use query builders for type safety
// - All errors mapped to ValidationError for consistency
//

import Foundation
import Models
import SQLiteData
import GRDB

/// Re-export wrapper types from ActionsQuery for use in repository
/// These will eventually be moved to a shared Models location
public struct ActionMeasurement: Identifiable, Hashable, Sendable {
    public let measuredAction: MeasuredAction
    public let measure: Measure
    public var id: UUID { measuredAction.id }

    public init(measuredAction: MeasuredAction, measure: Measure) {
        self.measuredAction = measuredAction
        self.measure = measure
    }
}

public struct ActionContribution: Identifiable, Hashable, Sendable {
    public let contribution: ActionGoalContribution
    public let goal: Goal
    public var id: UUID { contribution.id }

    public init(contribution: ActionGoalContribution, goal: Goal) {
        self.contribution = contribution
        self.goal = goal
    }
}

public struct ActionWithDetails: Identifiable, Hashable, Sendable {
    public let action: Action
    public let measurements: [ActionMeasurement]
    public let contributions: [ActionContribution]
    public var id: UUID { action.id }

    public init(
        action: Action,
        measurements: [ActionMeasurement] = [],
        contributions: [ActionContribution] = []
    ) {
        self.action = action
        self.measurements = measurements
        self.contributions = contributions
    }
}

// MARK: - Result Types for #sql Queries

/// Row type for #sql macro results when fetching actions with details
/// Must conform to FetchableRecord for GRDB compatibility
private struct ActionDetailsRow: Decodable, Sendable, FetchableRecord {
    // Action fields
    let actionId: UUID
    let actionTitle: String?
    let actionDescription: String?
    let actionNotes: String?
    let actionLogTime: Date
    let actionDuration: Double?
    let actionStartTime: Date?

    // MeasuredAction fields (nullable for LEFT JOIN)
    let measurementId: UUID?
    let measurementValue: Double?
    let measurementCreatedAt: Date?

    // Measure fields (nullable for LEFT JOIN)
    let measureId: UUID?
    let measureTitle: String?
    let measureUnit: String?
    let measureType: String?

    // ActionGoalContribution fields (nullable for LEFT JOIN)
    let contributionId: UUID?
    let contributionAmount: Double?
    let contributionCreatedAt: Date?

    // Goal fields (nullable for LEFT JOIN)
    let goalId: UUID?
    let goalExpectationId: UUID?
    let goalStartDate: Date?
    let goalTargetDate: Date?
    let goalActionPlan: String?

    enum CodingKeys: String, CodingKey {
        // Action columns
        case actionId = "action_id"
        case actionTitle = "action_title"
        case actionDescription = "action_description"
        case actionNotes = "action_notes"
        case actionLogTime = "action_logTime"
        case actionDuration = "action_duration"
        case actionStartTime = "action_startTime"

        // MeasuredAction columns
        case measurementId = "measurement_id"
        case measurementValue = "measurement_value"
        case measurementCreatedAt = "measurement_createdAt"

        // Measure columns
        case measureId = "measure_id"
        case measureTitle = "measure_title"
        case measureUnit = "measure_unit"
        case measureType = "measure_type"

        // Contribution columns
        case contributionId = "contribution_id"
        case contributionAmount = "contribution_amount"
        case contributionCreatedAt = "contribution_createdAt"

        // Goal columns
        case goalId = "goal_id"
        case goalExpectationId = "goal_expectationId"
        case goalStartDate = "goal_startDate"
        case goalTargetDate = "goal_targetDate"
        case goalActionPlan = "goal_actionPlan"
    }
}

/// Aggregate result for measure totals
/// Must conform to FetchableRecord for GRDB compatibility
private struct MeasureTotal: Decodable, Sendable, FetchableRecord {
    let total: Double
}

/// Aggregate result for counts
/// Must conform to FetchableRecord for GRDB compatibility
private struct CountResult: Decodable, Sendable, FetchableRecord {
    let count: Int
}

// MARK: - Repository Implementation

@MainActor
public final class ActionRepository {
    private let database: any DatabaseWriter

    public init(database: any DatabaseWriter) {
        self.database = database
    }

    // MARK: - Complex Queries (#sql macros)

    /// Fetch all actions with measurements and goal contributions using #sql macro
    /// Performance: Single query with JOINs instead of N+1 queries
    public func fetchAll() async throws -> [ActionWithDetails] {
        do {
            return try await database.read { db in
                // Use #sql macro for efficient multi-table JOIN
                let rows = try #sql(
                    """
                    SELECT
                        -- Action columns
                        actions.id as action_id,
                        actions.title as action_title,
                        actions.detailedDescription as action_description,
                        actions.freeformNotes as action_notes,
                        actions.logTime as action_logTime,
                        actions.durationMinutes as action_duration,
                        actions.startTime as action_startTime,

                        -- MeasuredAction columns
                        measuredActions.id as measurement_id,
                        measuredActions.value as measurement_value,
                        measuredActions.createdAt as measurement_createdAt,

                        -- Measure columns
                        measures.id as measure_id,
                        measures.title as measure_title,
                        measures.unit as measure_unit,
                        measures.measureType as measure_type,

                        -- ActionGoalContribution columns
                        actionGoalContributions.id as contribution_id,
                        actionGoalContributions.contributionAmount as contribution_amount,
                        actionGoalContributions.createdAt as contribution_createdAt,

                        -- Goal columns
                        goals.id as goal_id,
                        goals.expectationId as goal_expectationId,
                        goals.startDate as goal_startDate,
                        goals.targetDate as goal_targetDate,
                        goals.actionPlan as goal_actionPlan

                    FROM actions
                    LEFT JOIN measuredActions ON actions.id = measuredActions.actionId
                    LEFT JOIN measures ON measuredActions.measureId = measures.id
                    LEFT JOIN actionGoalContributions ON actions.id = actionGoalContributions.actionId
                    LEFT JOIN goals ON actionGoalContributions.goalId = goals.id
                    ORDER BY actions.logTime DESC
                    """,
                    as: ActionDetailsRow.self
                ).fetchAll(db)

                // Group and assemble results (validated by ActionValidator)
                return assembleActionDetails(from: rows)
            }
        } catch {
            throw mapDatabaseError(error)
        }
    }

    /// Fetch actions within a date range using #sql macro
    public func fetchByDateRange(_ range: ClosedRange<Date>) async throws -> [ActionWithDetails] {
        do {
            return try await database.read { db in
                let rows = try #sql(
                    """
                    SELECT
                        -- Action columns
                        actions.id as action_id,
                        actions.title as action_title,
                        actions.detailedDescription as action_description,
                        actions.freeformNotes as action_notes,
                        actions.logTime as action_logTime,
                        actions.durationMinutes as action_duration,
                        actions.startTime as action_startTime,

                        -- MeasuredAction columns
                        measuredActions.id as measurement_id,
                        measuredActions.value as measurement_value,
                        measuredActions.createdAt as measurement_createdAt,

                        -- Measure columns
                        measures.id as measure_id,
                        measures.title as measure_title,
                        measures.unit as measure_unit,
                        measures.measureType as measure_type,

                        -- ActionGoalContribution columns
                        actionGoalContributions.id as contribution_id,
                        actionGoalContributions.contributionAmount as contribution_amount,
                        actionGoalContributions.createdAt as contribution_createdAt,

                        -- Goal columns
                        goals.id as goal_id,
                        goals.expectationId as goal_expectationId,
                        goals.startDate as goal_startDate,
                        goals.targetDate as goal_targetDate,
                        goals.actionPlan as goal_actionPlan

                    FROM actions
                    LEFT JOIN measuredActions ON actions.id = measuredActions.actionId
                    LEFT JOIN measures ON measuredActions.measureId = measures.id
                    LEFT JOIN actionGoalContributions ON actions.id = actionGoalContributions.actionId
                    LEFT JOIN goals ON actionGoalContributions.goalId = goals.id
                    WHERE actions.logTime BETWEEN \(bind: range.lowerBound) AND \(bind: range.upperBound)
                    ORDER BY actions.logTime DESC
                    """,
                    as: ActionDetailsRow.self
                ).fetchAll(db)

                return assembleActionDetails(from: rows)
            }
        } catch {
            throw mapDatabaseError(error)
        }
    }

    /// Fetch actions contributing to a specific goal using #sql macro
    public func fetchByGoal(_ goalId: UUID) async throws -> [ActionWithDetails] {
        do {
            return try await database.read { db in
                let rows = try #sql(
                    """
                    SELECT
                        -- Action columns
                        actions.id as action_id,
                        actions.title as action_title,
                        actions.detailedDescription as action_description,
                        actions.freeformNotes as action_notes,
                        actions.logTime as action_logTime,
                        actions.durationMinutes as action_duration,
                        actions.startTime as action_startTime,

                        -- MeasuredAction columns
                        measuredActions.id as measurement_id,
                        measuredActions.value as measurement_value,
                        measuredActions.createdAt as measurement_createdAt,

                        -- Measure columns
                        measures.id as measure_id,
                        measures.title as measure_title,
                        measures.unit as measure_unit,
                        measures.measureType as measure_type,

                        -- ActionGoalContribution columns
                        actionGoalContributions.id as contribution_id,
                        actionGoalContributions.contributionAmount as contribution_amount,
                        actionGoalContributions.createdAt as contribution_createdAt,

                        -- Goal columns
                        goals.id as goal_id,
                        goals.expectationId as goal_expectationId,
                        goals.startDate as goal_startDate,
                        goals.targetDate as goal_targetDate,
                        goals.actionPlan as goal_actionPlan

                    FROM actions
                    INNER JOIN actionGoalContributions ON actions.id = actionGoalContributions.actionId
                    LEFT JOIN measuredActions ON actions.id = measuredActions.actionId
                    LEFT JOIN measures ON measuredActions.measureId = measures.id
                    LEFT JOIN goals ON actionGoalContributions.goalId = goals.id
                    WHERE actionGoalContributions.goalId = \(bind: goalId)
                    ORDER BY actions.logTime DESC
                    """,
                    as: ActionDetailsRow.self
                ).fetchAll(db)

                return assembleActionDetails(from: rows)
            }
        } catch {
            throw mapDatabaseError(error)
        }
    }

    /// Fetch recent actions with a limit
    public func fetchRecentActions(limit: Int) async throws -> [ActionWithDetails] {
        do {
            return try await database.read { db in
                let rows = try #sql(
                    """
                    SELECT
                        -- Action columns
                        actions.id as action_id,
                        actions.title as action_title,
                        actions.detailedDescription as action_description,
                        actions.freeformNotes as action_notes,
                        actions.logTime as action_logTime,
                        actions.durationMinutes as action_duration,
                        actions.startTime as action_startTime,

                        -- MeasuredAction columns
                        measuredActions.id as measurement_id,
                        measuredActions.value as measurement_value,
                        measuredActions.createdAt as measurement_createdAt,

                        -- Measure columns
                        measures.id as measure_id,
                        measures.title as measure_title,
                        measures.unit as measure_unit,
                        measures.measureType as measure_type,

                        -- ActionGoalContribution columns
                        actionGoalContributions.id as contribution_id,
                        actionGoalContributions.contributionAmount as contribution_amount,
                        actionGoalContributions.createdAt as contribution_createdAt,

                        -- Goal columns
                        goals.id as goal_id,
                        goals.expectationId as goal_expectationId,
                        goals.startDate as goal_startDate,
                        goals.targetDate as goal_targetDate,
                        goals.actionPlan as goal_actionPlan

                    FROM actions
                    LEFT JOIN measuredActions ON actions.id = measuredActions.actionId
                    LEFT JOIN measures ON measuredActions.measureId = measures.id
                    LEFT JOIN actionGoalContributions ON actions.id = actionGoalContributions.actionId
                    LEFT JOIN goals ON actionGoalContributions.goalId = goals.id
                    WHERE actions.id IN (
                        SELECT id FROM actions
                        ORDER BY logTime DESC
                        LIMIT \(bind: limit)
                    )
                    ORDER BY actions.logTime DESC
                    """,
                    as: ActionDetailsRow.self
                ).fetchAll(db)

                return assembleActionDetails(from: rows)
            }
        } catch {
            throw mapDatabaseError(error)
        }
    }

    // MARK: - Aggregations (#sql for performance)

    /// Calculate total value for a measure within a date range
    public func totalByMeasure(_ measureId: UUID, in range: ClosedRange<Date>) async throws -> Double {
        do {
            return try await database.read { db in
                let result = try #sql(
                    """
                    SELECT COALESCE(SUM(measuredActions.value), 0.0) as total
                    FROM measuredActions
                    INNER JOIN actions ON measuredActions.actionId = actions.id
                    WHERE measuredActions.measureId = \(bind: measureId)
                      AND actions.logTime BETWEEN \(bind: range.lowerBound) AND \(bind: range.upperBound)
                    """,
                    as: MeasureTotal.self
                ).fetchOne(db)

                return result?.total ?? 0.0
            }
        } catch {
            throw mapDatabaseError(error)
        }
    }

    /// Count actions contributing to a specific goal
    public func countByGoal(_ goalId: UUID) async throws -> Int {
        do {
            return try await database.read { db in
                let result = try #sql(
                    """
                    SELECT COUNT(DISTINCT actionId) as count
                    FROM actionGoalContributions
                    WHERE goalId = \(bind: goalId)
                    """,
                    as: CountResult.self
                ).fetchOne(db)

                return result?.count ?? 0
            }
        } catch {
            throw mapDatabaseError(error)
        }
    }

    // MARK: - Simple Queries (query builders for type safety)

    /// Check if an action exists by title and date
    /// Used to prevent duplicate action entries
    public func exists(title: String, on date: Date) async throws -> Bool {
        do {
            return try await database.read { db in
                // Calculate date range for the given day
                let calendar = Calendar.current
                let startOfDay = calendar.startOfDay(for: date)
                let endOfDay = calendar.date(byAdding: .day, value: 1, to: startOfDay)!

                // Use query builder for simple existence check
                let count = try Action
                    .where { $0.title.eq(title) && $0.logTime >= startOfDay && $0.logTime < endOfDay }
                    .fetchCount(db)

                return count > 0
            }
        } catch {
            throw mapDatabaseError(error)
        }
    }

    /// Check if an action exists by ID
    public func exists(_ id: UUID) async throws -> Bool {
        do {
            return try await database.read { db in
                try Action.find(id).fetchOne(db) != nil
            }
        } catch {
            throw mapDatabaseError(error)
        }
    }

    // MARK: - Private Helpers

    /// Assemble ActionWithDetails from flat row results
    /// Groups rows by action and reconstructs the object graph
    private func assembleActionDetails(from rows: [ActionDetailsRow]) -> [ActionWithDetails] {
        // Group rows by action ID
        let groupedByAction = Dictionary(grouping: rows) { $0.actionId }

        // Build ActionWithDetails for each unique action
        return groupedByAction.compactMap { (actionId, actionRows) in
            // Take first row for action data (same across all rows for this action)
            guard let firstRow = actionRows.first else { return nil }

            // Reconstruct Action
            let action = Action(
                id: firstRow.actionId,
                title: firstRow.actionTitle,
                detailedDescription: firstRow.actionDescription,
                freeformNotes: firstRow.actionNotes,
                logTime: firstRow.actionLogTime,
                durationMinutes: firstRow.actionDuration,
                startTime: firstRow.actionStartTime
            )

            // Collect unique measurements
            var measurementsDict: [UUID: ActionMeasurement] = [:]
            for row in actionRows {
                if let measurementId = row.measurementId,
                   let measureId = row.measureId,
                   let value = row.measurementValue,
                   let createdAt = row.measurementCreatedAt,
                   let measureTitle = row.measureTitle,
                   let measureUnit = row.measureUnit,
                   let measureType = row.measureType {

                    let measuredAction = MeasuredAction(
                        id: measurementId,
                        actionId: actionId,
                        measureId: measureId,
                        value: value,
                        createdAt: createdAt
                    )

                    let measure = Measure(
                        id: measureId,
                        title: measureTitle,
                        detailedDescription: nil,
                        freeformNotes: nil,
                        logTime: Date(), // Not included in query, use placeholder
                        unit: measureUnit,
                        measureType: measureType,
                        canonicalUnit: nil,
                        conversionFactor: nil
                    )

                    measurementsDict[measurementId] = ActionMeasurement(
                        measuredAction: measuredAction,
                        measure: measure
                    )
                }
            }

            // Collect unique contributions
            var contributionsDict: [UUID: ActionContribution] = [:]
            for row in actionRows {
                if let contributionId = row.contributionId,
                   let goalId = row.goalId,
                   let createdAt = row.contributionCreatedAt,
                   let expectationId = row.goalExpectationId,
                   let startDate = row.goalStartDate,
                   let targetDate = row.goalTargetDate {

                    let contribution = ActionGoalContribution(
                        id: contributionId,
                        actionId: actionId,
                        goalId: goalId,
                        contributionAmount: row.contributionAmount,
                        measureId: nil, // Not included in query
                        createdAt: createdAt
                    )

                    let goal = Goal(
                        id: goalId,
                        expectationId: expectationId,
                        startDate: startDate,
                        targetDate: targetDate,
                        actionPlan: row.goalActionPlan,
                        expectedTermLength: nil // Not included in query
                    )

                    contributionsDict[contributionId] = ActionContribution(
                        contribution: contribution,
                        goal: goal
                    )
                }
            }

            return ActionWithDetails(
                action: action,
                measurements: Array(measurementsDict.values),
                contributions: Array(contributionsDict.values)
            )
        }
        .sorted { $0.action.logTime > $1.action.logTime } // Maintain order
    }

    /// Map database errors to user-friendly validation errors
    private func mapDatabaseError(_ error: Error) -> ValidationError {
        // Check for GRDB-specific errors
        if let dbError = error as? DatabaseError {
            // Foreign key violation
            if dbError.resultCode == .SQLITE_CONSTRAINT {
                if dbError.message?.contains("FOREIGN KEY") == true {
                    if dbError.message?.contains("measureId") == true {
                        return .invalidMeasure("Measure not found")
                    }
                    if dbError.message?.contains("goalId") == true {
                        return .invalidGoal("Goal not found")
                    }
                    return .foreignKeyViolation("Referenced entity not found")
                }
                // Unique constraint violation
                if dbError.message?.contains("UNIQUE") == true {
                    return .duplicateRecord("This entry already exists")
                }
                // Not null constraint
                if dbError.message?.contains("NOT NULL") == true {
                    return .missingRequiredField("Required field is missing")
                }
            }
        }

        // Generic database error
        return .databaseConstraint(error.localizedDescription)
    }
}
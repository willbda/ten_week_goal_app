//
// ActionRepositoryUpdated.swift.disabled
// Written by Claude Code on 2025-11-15
//
// PURPOSE:
// Exploration of single canonical data type approach for repositories.
// Eliminates duplication between display and export by using one struct.
//
// KEY CHANGES FROM CURRENT ActionRepository:
// 1. ActionData is the ONE canonical type (Codable, Sendable, Identifiable, Hashable)
// 2. fetchAll() returns [ActionData] (not [ActionWithDetails])
// 3. Extension provides .asDetails computed property for views that need it
// 4. Export uses ActionData directly (already Codable)
// 5. Eliminates: assembleActionWithDetails(), assembleActionExport()
//

import Foundation
import Models
import SQLiteData
import GRDB

// MARK: - Canonical Data Type

/// Canonical action data structure - serves both display and export needs
///
/// **Design Philosophy**:
/// - ONE struct to rule them all (not 3+ separate types)
/// - Codable for JSON/CSV export
/// - Sendable for Swift 6 concurrency
/// - Identifiable + Hashable for SwiftUI
/// - Flat structure (simple arrays, no nested wrapper types)
///
/// **Usage**:
/// ```swift
/// // Repository returns this
/// let actions = try await repository.fetchAll()
///
/// // Export uses it directly
/// let json = try JSONEncoder().encode(actions)
///
/// // Views transform if they need nested structure
/// let details = actions.map { $0.asDetails }
/// ```
public struct ActionData: Identifiable, Hashable, Sendable, Codable {
    // MARK: - Core Action Fields

    public let id: UUID
    public let title: String?
    public let detailedDescription: String?
    public let freeformNotes: String?
    public let logTime: Date
    public let durationMinutes: Double?
    public let startTime: Date?

    // MARK: - Denormalized Measurements

    /// Flat measurement data (no nested MeasuredAction entities)
    public struct Measurement: Identifiable, Hashable, Sendable, Codable {
        public let id: UUID              // measuredAction.id
        public let measureId: UUID
        public let measureTitle: String?
        public let measureUnit: String
        public let measureType: String
        public let value: Double
        public let createdAt: Date

        public init(
            id: UUID,
            measureId: UUID,
            measureTitle: String?,
            measureUnit: String,
            measureType: String,
            value: Double,
            createdAt: Date
        ) {
            self.id = id
            self.measureId = measureId
            self.measureTitle = measureTitle
            self.measureUnit = measureUnit
            self.measureType = measureType
            self.value = value
            self.createdAt = createdAt
        }
    }

    public let measurements: [Measurement]

    // MARK: - Denormalized Contributions

    /// Flat contribution data (no nested Goal entities)
    public struct Contribution: Identifiable, Hashable, Sendable, Codable {
        public let id: UUID              // contribution.id
        public let goalId: UUID
        public let goalTitle: String?    // For display convenience
        public let contributionAmount: Double?
        public let measureId: UUID?
        public let createdAt: Date

        public init(
            id: UUID,
            goalId: UUID,
            goalTitle: String?,
            contributionAmount: Double?,
            measureId: UUID?,
            createdAt: Date
        ) {
            self.id = id
            self.goalId = goalId
            self.goalTitle = goalTitle
            self.contributionAmount = contributionAmount
            self.measureId = measureId
            self.createdAt = createdAt
        }
    }

    public let contributions: [Contribution]

    public init(
        id: UUID,
        title: String?,
        detailedDescription: String?,
        freeformNotes: String?,
        logTime: Date,
        durationMinutes: Double?,
        startTime: Date?,
        measurements: [Measurement],
        contributions: [Contribution]
    ) {
        self.id = id
        self.title = title
        self.detailedDescription = detailedDescription
        self.freeformNotes = freeformNotes
        self.logTime = logTime
        self.durationMinutes = durationMinutes
        self.startTime = startTime
        self.measurements = measurements
        self.contributions = contributions
    }
}

// MARK: - Convenience Transformations

extension ActionData {
    /// Transform to ActionWithDetails for views that need nested entity structure
    ///
    /// **When to use**: SwiftUI views that bind to nested entities
    /// **When NOT to use**: Export, API responses, most list views
    ///
    /// **Note**: This creates placeholder entities (Goal with just ID).
    /// If you need full Goal details, fetch separately.
    public var asDetails: ActionWithDetails {
        let action = Action(
            title: title,
            detailedDescription: detailedDescription,
            freeformNotes: freeformNotes,
            durationMinutes: durationMinutes,
            startTime: startTime,
            logTime: logTime,
            id: id
        )

        let actionMeasurements = measurements.map { m in
            let measuredAction = MeasuredAction(
                actionId: id,
                measureId: m.measureId,
                value: m.value,
                createdAt: m.createdAt,
                id: m.id
            )

            let measure = Measure(
                unit: m.measureUnit,
                measureType: m.measureType,
                title: m.measureTitle,
                detailedDescription: nil,
                freeformNotes: nil,
                canonicalUnit: nil,
                conversionFactor: nil,
                logTime: m.createdAt,  // Placeholder
                id: m.measureId
            )

            return ActionMeasurement(measuredAction: measuredAction, measure: measure)
        }

        let actionContributions = contributions.map { c in
            let contribution = ActionGoalContribution(
                actionId: id,
                goalId: c.goalId,
                contributionAmount: c.contributionAmount,
                measureId: c.measureId,
                createdAt: c.createdAt,
                id: c.id
            )

            // Placeholder goal (just ID and title)
            let goal = Goal(
                expectationId: UUID(),  // Placeholder
                startDate: nil,
                targetDate: nil,
                actionPlan: nil,
                expectedTermLength: nil,
                id: c.goalId
            )

            return ActionContribution(contribution: contribution, goal: goal)
        }

        return ActionWithDetails(
            action: action,
            measurements: actionMeasurements,
            contributions: actionContributions
        )
    }

    /// Convenience accessor for goal IDs (for simple list displays)
    public var contributingGoalIds: [UUID] {
        contributions.map { $0.goalId }
    }
}

// MARK: - Repository Implementation

public final class ActionRepositoryUpdated: Sendable {
    private let database: any DatabaseWriter

    public init(database: any DatabaseWriter) {
        self.database = database
    }

    // MARK: - Single Fetch Method

    /// Fetch all actions with measurements and contributions
    ///
    /// **Returns**: Canonical ActionData array
    /// **Usage**:
    /// - Export: Use directly (already Codable)
    /// - Views: Transform with `.map { $0.asDetails }` if needed
    public func fetchAll() async throws -> [ActionData] {
        do {
            return try await database.read { db in
                let rows = try ActionQueryRow.fetchAll(db, sql: fetchAllSQL)
                return try rows.map { row in
                    try assembleActionData(from: row)
                }
            }
        } catch {
            throw mapDatabaseError(error)
        }
    }

    /// Fetch actions within date range
    public func fetchByDateRange(_ range: ClosedRange<Date>) async throws -> [ActionData] {
        do {
            return try await database.read { db in
                let sql = """
                \(baseQuerySQL)
                WHERE a.logTime BETWEEN ? AND ?
                ORDER BY a.logTime DESC
                """

                let rows = try ActionQueryRow.fetchAll(db, sql: sql, arguments: [range.lowerBound, range.upperBound])
                return try rows.map { row in
                    try assembleActionData(from: row)
                }
            }
        } catch {
            throw mapDatabaseError(error)
        }
    }

    /// Fetch actions contributing to a goal
    public func fetchByGoal(_ goalId: UUID) async throws -> [ActionData] {
        do {
            return try await database.read { db in
                let sql = """
                \(baseQuerySQL)
                WHERE EXISTS (
                    SELECT 1 FROM actionGoalContributions agc2
                    WHERE agc2.actionId = a.id AND agc2.goalId = ?
                )
                ORDER BY a.logTime DESC
                """

                let rows = try ActionQueryRow.fetchAll(db, sql: sql, arguments: [goalId])
                return try rows.map { row in
                    try assembleActionData(from: row)
                }
            }
        } catch {
            throw mapDatabaseError(error)
        }
    }

    // MARK: - Existence Checks

    public func exists(_ id: UUID) async throws -> Bool {
        do {
            return try await database.read { db in
                try Action.find(id).fetchOne(db) != nil
            }
        } catch {
            throw mapDatabaseError(error)
        }
    }

    // MARK: - Error Mapping

    private func mapDatabaseError(_ error: Error) -> ValidationError {
        guard let dbError = error as? DatabaseError else {
            return .databaseConstraint(error.localizedDescription)
        }

        switch dbError.resultCode {
        case .SQLITE_CONSTRAINT_UNIQUE:
            return .duplicateRecord("This action already exists")
        case .SQLITE_CONSTRAINT_NOTNULL:
            return .missingRequiredField("Required field is missing")
        case .SQLITE_CONSTRAINT_FOREIGNKEY:
            return .foreignKeyViolation("Referenced entity not found")
        case .SQLITE_CONSTRAINT:
            return .databaseConstraint(dbError.message ?? "Database constraint violated")
        default:
            return .databaseConstraint(dbError.localizedDescription)
        }
    }
}

// MARK: - SQL Queries (SAME as current repository)

extension ActionRepositoryUpdated {
    private var baseQuerySQL: String {
        """
        SELECT
            a.id as actionId,
            a.title as actionTitle,
            a.detailedDescription as actionDetailedDescription,
            a.freeformNotes as actionFreeformNotes,
            a.logTime as actionLogTime,
            a.durationMinutes as actionDurationMinutes,
            a.startTime as actionStartTime,

            -- Measurements JSON array
            COALESCE(
                (
                    SELECT json_group_array(
                        json_object(
                            'measuredActionId', ma.id,
                            'value', ma.value,
                            'createdAt', ma.createdAt,
                            'measureId', m.id,
                            'measureTitle', m.title,
                            'measureUnit', m.unit,
                            'measureType', m.measureType
                        )
                    )
                    FROM measuredActions ma
                    JOIN measures m ON ma.measureId = m.id
                    WHERE ma.actionId = a.id
                ),
                '[]'
            ) as measurementsJson,

            -- Contributions JSON array (WITH goal title for convenience)
            COALESCE(
                (
                    SELECT json_group_array(
                        json_object(
                            'contributionId', agc.id,
                            'contributionAmount', agc.contributionAmount,
                            'measureId', agc.measureId,
                            'createdAt', agc.createdAt,
                            'goalId', g.id,
                            'goalTitle', e.title
                        )
                    )
                    FROM actionGoalContributions agc
                    JOIN goals g ON agc.goalId = g.id
                    JOIN expectations e ON g.expectationId = e.id
                    WHERE agc.actionId = a.id
                ),
                '[]'
            ) as contributionsJson

        FROM actions a
        """
    }

    private var fetchAllSQL: String {
        """
        \(baseQuerySQL)
        ORDER BY a.logTime DESC
        """
    }
}

// MARK: - Row Types (SAME as current repository)

/// Result row from JSON aggregation query
public struct ActionQueryRow: Codable, FetchableRecord, Sendable {
    let actionId: String
    let actionTitle: String?
    let actionDetailedDescription: String?
    let actionFreeformNotes: String?
    let actionLogTime: String
    let actionDurationMinutes: Double?
    let actionStartTime: String?

    let measurementsJson: String
    let contributionsJson: String
}

/// Decoded measurement from JSON array
private struct MeasurementJsonRow: Decodable, Sendable {
    let measuredActionId: String
    let value: Double
    let createdAt: String
    let measureId: String
    let measureTitle: String?
    let measureUnit: String
    let measureType: String
}

/// Decoded contribution from JSON array (NOW includes goalTitle)
private struct ContributionJsonRow: Decodable, Sendable {
    let contributionId: String
    let contributionAmount: Double?
    let measureId: String?
    let createdAt: String
    let goalId: String
    let goalTitle: String?  // NEW: For display convenience
}

// MARK: - Assembly Function (ONE function, not two)

/// Assemble ActionData from JSON query row
///
/// **Key Difference**: Only ONE assembly function (not separate for display vs export)
/// **Process**:
/// 1. Parse JSON strings to structured arrays
/// 2. Convert to ActionData.Measurement and ActionData.Contribution
/// 3. Return canonical ActionData
///
/// Consumer decides how to use it:
/// - Export: Use directly (Codable)
/// - Views: Call .asDetails if needed
private func assembleActionData(from row: ActionQueryRow) throws -> ActionData {
    let decoder = JSONDecoder()

    // Parse action fields
    guard let actionUUID = UUID(uuidString: row.actionId) else {
        throw ValidationError.databaseConstraint("Invalid action ID: \(row.actionId)")
    }

    // Parse measurements JSON
    let measurementsData = row.measurementsJson.data(using: .utf8)!
    let measurementsJson = try decoder.decode([MeasurementJsonRow].self, from: measurementsData)

    let measurements: [ActionData.Measurement] = try measurementsJson.map { m in
        guard let measuredActionUUID = UUID(uuidString: m.measuredActionId),
              let measureUUID = UUID(uuidString: m.measureId) else {
            throw ValidationError.databaseConstraint("Invalid UUID in measurement")
        }

        return ActionData.Measurement(
            id: measuredActionUUID,
            measureId: measureUUID,
            measureTitle: m.measureTitle,
            measureUnit: m.measureUnit,
            measureType: m.measureType,
            value: m.value,
            createdAt: parseDate(m.createdAt) ?? Date()
        )
    }

    // Parse contributions JSON
    let contributionsData = row.contributionsJson.data(using: .utf8)!
    let contributionsJson = try decoder.decode([ContributionJsonRow].self, from: contributionsData)

    let contributions: [ActionData.Contribution] = try contributionsJson.map { c in
        guard let contributionUUID = UUID(uuidString: c.contributionId),
              let goalUUID = UUID(uuidString: c.goalId) else {
            throw ValidationError.databaseConstraint("Invalid UUID in contribution")
        }

        let measureUUID: UUID? = if let mid = c.measureId {
            UUID(uuidString: mid)
        } else {
            nil
        }

        return ActionData.Contribution(
            id: contributionUUID,
            goalId: goalUUID,
            goalTitle: c.goalTitle,  // From JOIN with expectations
            contributionAmount: c.contributionAmount,
            measureId: measureUUID,
            createdAt: parseDate(c.createdAt) ?? Date()
        )
    }

    return ActionData(
        id: actionUUID,
        title: row.actionTitle,
        detailedDescription: row.actionDetailedDescription,
        freeformNotes: row.actionFreeformNotes,
        logTime: parseDate(row.actionLogTime) ?? Date(),
        durationMinutes: row.actionDurationMinutes,
        startTime: parseDate(row.actionStartTime),
        measurements: measurements,
        contributions: contributions
    )
}

// MARK: - Date Parsing Helper

private func parseDate(_ dateString: String?) -> Date? {
    guard let dateString = dateString else { return nil }
    let formatter = ISO8601DateFormatter()
    return formatter.date(from: dateString)
}

// MARK: - Usage Examples

/*

 ## Example 1: Export (Direct usage, no transformation)

 ```swift
 let repository = ActionRepositoryUpdated(database: database)
 let actions = try await repository.fetchAll()

 // JSON export - ActionData is already Codable
 let encoder = JSONEncoder()
 encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
 encoder.dateEncodingStrategy = .iso8601
 let jsonData = try encoder.encode(actions)

 // CSV export - access flat properties directly
 for action in actions {
     let row = [
         action.id.uuidString,
         action.title ?? "",
         action.logTime.ISO8601Format(),
         action.measurements.map { $0.measureTitle ?? "" }.joined(separator: ";"),
         action.contributingGoalIds.map { $0.uuidString }.joined(separator: ";")
     ].joined(separator: ",")
     print(row)
 }
 ```

 ## Example 2: Simple List View (Direct usage)

 ```swift
 @Observable
 @MainActor
 class ActionsListViewModel {
     var actions: [ActionData] = []

     func loadActions() async {
         actions = try await repository.fetchAll()
     }
 }

 struct ActionsListView: View {
     @State private var viewModel = ActionsListViewModel()

     var body: some View {
         List(viewModel.actions) { action in
             VStack(alignment: .leading) {
                 Text(action.title ?? "Untitled")
                 Text("\(action.measurements.count) measurements")
                 Text("Goals: \(action.contributingGoalIds.map { $0.uuidString.prefix(8) }.joined(separator: ", "))")
             }
         }
     }
 }
 ```

 ## Example 3: Detail View (Transform to nested structure)

 ```swift
 struct ActionDetailView: View {
     let action: ActionData

     var body: some View {
         // If you need ActionWithDetails for binding purposes
         let details = action.asDetails

         Form {
             Section("Measurements") {
                 ForEach(details.measurements) { measurement in
                     Text("\(measurement.measure.title ?? "Unknown"): \(measurement.measuredAction.value)")
                 }
             }
         }
     }
 }
 ```

 ## Example 4: Comparison with Current Approach

 ### Current (ActionRepository):
 ```swift
 // Display path
 let displayActions = try await repository.fetchAll()  // [ActionWithDetails]
 // Export path
 let exportActions = try await repository.fetchForExport()  // [ActionExport]
 // Two different types, two assembly functions
 ```

 ### Updated (ActionRepositoryUpdated):
 ```swift
 // Both paths use same data
 let actions = try await repository.fetchAll()  // [ActionData]

 // Export uses directly
 let json = try JSONEncoder().encode(actions)

 // Display transforms if needed
 let details = actions.map { $0.asDetails }
 ```

 ## Benefits:

 1. **Single Source of Truth**: One struct (ActionData) instead of 3+ (ActionQueryRow, ActionWithDetails, ActionExport)
 2. **Less Code**: One assembly function instead of two (assembleActionWithDetails, assembleActionExport)
 3. **Export-Ready by Default**: ActionData is Codable, no separate export type needed
 4. **View Flexibility**: Views can use ActionData directly OR transform to ActionWithDetails
 5. **Maintainability**: Changes to data structure only need updating in one place

 ## Tradeoffs:

 1. **Views Need Transformation**: If views want nested entities, they call .asDetails (extra step)
 2. **Placeholder Entities**: .asDetails creates placeholder Goals (just ID+title), not full entities
 3. **Different Pattern**: Current codebase uses ActionWithDetails everywhere, this would be a shift

 */
